# Custom Spans In Tracing

GoFr's built-in tracing provides valuable insights into application's behavior. However, sometimes you might need 
even more granular details about specific operations within your application. This is where `custom spans` can be used.

## How it helps?
By adding custom spans in traces to your requests, you can:

- **Gain granular insights:** Custom spans allow you to track specific operations or functions within your application, 
     providing detailed performance data.
- **Identify bottlenecks:** Analyzing custom spans helps to pinpoint areas of your code that may be causing 
      performance bottlenecks or inefficiencies.
- **Improve debugging:** Custom spans enhance the ability to debug issues by providing visibility into the execution 
      flow of an application.

## Usage

To add a custom trace to a request, GoFr context provides `Trace()` method, which takes the name of the span as an argument 
and returns a trace.Span. 

```go
func MyHandler(c context.Context) error {
    span := c.Trace("my-custom-span")
    defer span.Close()
    
    // Do some work here
    return nil
}
```

In this example, **my-custom-span** is the name of the custom span that is added to the request.
The defer statement ensures that the span is closed even if an error occurs to ensure that the trace is properly recorded.

> ##### Check out the example of creating a custom span in GoFr: [Visit Github](https://github.com/gofr-dev/gofr/blob/main/examples/http-server/main.go#L58)
# Error Handling

GoFr provides a structured error handling approach to simplify error management in your applications. 
The errors package in GoFr provides functionality for handling errors in GoFr applications. It includes predefined HTTP 
and database errors, as well as the ability to create custom errors with additional context.

## Pre-defined HTTP Errors

GoFrâ€™s `http` package offers several predefined error types to represent common HTTP error scenarios. These errors 
automatically handle HTTP status code selection. These include:

- `ErrorInvalidParam`: Represents an error due to an invalid parameter.
- `ErrorMissingParam`: Represents an error due to a missing parameter.
- `ErrorEntityNotFound`: Represents an error due to a not found entity.
- `ErrorEntityAlreadyExist`: Represents an error due to creation of duplicate entity.
- `ErrorInvalidRoute`: Represents an error for invalid route.
- `ErrorRequestTimeout`: Represents an error for request which timed out.
- `ErrorPanicRecovery`: Represents an error for request which panicked.

#### Usage:
To use the predefined http errors,users can simply call them using GoFr's http package:
```go
 err := http.ErrorMissingParam{Param: []string{"id"}}
```

## Database Errors
Database errors in GoFr, represented in the `datasource` package, encapsulate errors related to database operations such
as database connection, query failure, availability etc. The `ErrorDB` struct can be used to populate `error` as well as 
any custom message to it.

#### Usage:
```go
// Creating a custom error wrapped in  underlying error for database operations
dbErr := datasource.ErrorDB{Err: err, Message: "error from sql db"}

// Adding stack trace to the error
dbErr = dbErr.WithStack()

// Creating a custom error only with error message and no underlying error.
dbErr2 := datasource.ErrorDB{Message : "database connection timed out!"}
```

## Custom Errors
GoFr's error structs implements an interface with `Error() string` and `StatusCode() int` methods, users can override the 
status code by implementing it for their custom error.

#### Usage:
```go
type customError struct {
	error string
}

func (c customError) Error() string {
	return fmt.Sprintf("custom error: %s", c.error)
}

func (c customError) StatusCode() int {
	return http.StatusMethodNotAllowed
}
```
# Handling Data Migrations

Suppose you manually make changes to your database, and now it's your responsibility to inform other developers to execute them. Additionally, you need to keep track of which changes should be applied to production machines in the next deployment.
GoFr supports data migrations for MySQL, Postgres, Redis, Clickhouse & Cassandra which allows altering the state of a database, be it adding a new column to existing table or modifying the data type of existing column or adding constraints to an existing table, setting and removing keys etc.

## Usage

### Creating Migration Files

It is recommended to maintain a `migrations` directory in your project root to enhance readability and maintainability.

**Migration file names**

It is recommended that each migration file should be numbered in the format of _YYYYMMDDHHMMSS_ when the migration was created.
This helps prevent numbering conflicts and allows for maintaining the correct sort order by name in different filesystem views.

Create the following file in `migrations` directory.

**Filename : 20240226153000_create_employee_table.go**

```go
package migrations

import "gofr.dev/pkg/gofr/migration"


const createTable = `CREATE TABLE IF NOT EXISTS employee
(
    id             int         not null
        primary key,
    name           varchar(50) not null,
    gender         varchar(6)  not null,
    contact_number varchar(10) not null
);`

func createTableEmployee() migration.Migrate {
	return migration.Migrate{
		UP: func(d migration.Datasource) error {
			_, err := d.SQL.Exec(createTable)
			if err != nil {
				return err
			}
			return nil
		},
	}
}
```

`migration.Datasource` have the datasources whose migrations are supported i.e., Redis and SQL (MySQL and PostgreSQL).
All migrations always run in a transaction.

For MySQL it is highly recommended to use `IF EXISTS` and `IF NOT EXIST` in DDL commands as MySQL implicitly commits these commands.

**Create a function which returns all the migrations in a map**

**Filename : all.go**

```go
package migrations

import "gofr.dev/pkg/gofr/migration"

func All() map[int64]migration.Migrate {
	return map[int64]migration.Migrate{
		20240226153000: createTableEmployee(),
	}
}
```

Migrations run in ascending order of keys in this map.

### Initialisation from main.go

```go
package main

import (
	"gofr.dev/examples/using-migrations/migrations"
	"gofr.dev/pkg/gofr"
)

func main() {
	// Create a new application
	a := gofr.New()

	// Add migrations to run
	a.Migrate(migrations.All())

	// Run the application
	a.Run()
}

```

When we run the app we will see the following logs for migrations which ran successfully.

```bash
INFO [16:55:46] Migration 20240226153000 ran successfully
```

GoFr maintains the records in the database itself which helps in tracking which migrations have already been executed and ensures that only migrations that have never been run are executed.

## Migration Records

**SQL**

Migration records are stored and maintained in **gofr_migrations** table which has the following schema:

{% table %}

- Field
- Type

---

- version
- bigint

---

- method
- varchar(4)

---

- start_time
- timestamp

---

- duration
- bigint

---

{% /table %}

**REDIS**

Migration records are stored and maintained in a Redis Hash named **gofr_migrations** where key is the version and value contains other details in JSON format.

Example :

Key : 20240226153000

Value : {"method":"UP","startTime":"2024-02-26T15:03:46.844558+05:30","duration":0}

Where,

**Version** : Migration version is the number provided in the map, i.e., sequence number.

**Start Time** : Time when Migration Started in UTC.

**Duration** : Time taken by Migration since it started in milliseconds.

**Method** : It contains the method(UP/DOWN) in which migration ran.
(For now only method UP is supported)

### Migrations in Cassandra

`GoFr` provides support for migrations in Cassandra but does not guarantee atomicity for individual Data Manipulation Language (DML) commands. To achieve atomicity during migrations, users can leverage batch operations using the `NewBatch`, `BatchQuery`, and `ExecuteBatch` methods. These methods allow multiple queries to be executed as a single atomic operation.

Alternatively, users can construct their batch queries using the `BEGIN BATCH` and `APPLY BATCH` statements to ensure that all the commands within the batch are executed successfully or not at all. This is particularly useful for complex migrations involving multiple inserts, updates, or schema changes in a single transaction-like operation.

When using batch operations, consider using a `LoggedBatch` for atomicity or an `UnloggedBatch` for improved performance where atomicity isn't required. This approach provides a way to maintain data consistency during complex migrations.

> Note: The following example assumes that user has already created the `KEYSPACE` in cassandra. A `KEYSPACE` in Cassandra is a container for tables that defines data replication settings across the cluster.


```go
package migrations

import (
    "gofr.dev/pkg/gofr/migration"
)

const (
	createTableCassandra = `CREATE TABLE IF NOT EXISTS employee (
                            id int PRIMARY KEY,
                            name text,
                            gender text,
                            number text
                            );`
	
	addCassandraRecords = `BEGIN BATCH
                           INSERT INTO employee (id, name, gender, number) VALUES (1, 'Alison', 'F', '1234567980');
                           INSERT INTO employee (id, name, gender, number) VALUES (2, 'Alice', 'F', '9876543210');
                           APPLY BATCH;
                           `
	
	employeeDataCassandra = `INSERT INTO employee (id, name, gender, number) VALUES (?, ?, ?, ?);`
)

func createTableEmployeeCassandra() migration.Migrate {
    return migration.Migrate{
        UP: func(d migration.Datasource) error {
            // Execute the create table statement
            if err := d.Cassandra.Exec(createTableCassandra); err != nil {
                return err
            }

            // Batch processes can also be executed in Exec as follows:
			if err := d.Cassandra.Exec(addCassandraRecords); err != nil {
				return err
			}	

            // Create a new batch operation
            batchName := "employeeBatch"
            if err := d.Cassandra.NewBatch(batchName, 0); err != nil { // 0 for LoggedBatch
                return err
            }

            // Add multiple queries to the batch
            if err := d.Cassandra.BatchQuery(batchName, employeeDataCassandra, 1, "Harry", "M", "1234567980"); err != nil {
                return err
            }

            if err := d.Cassandra.BatchQuery(batchName, employeeDataCassandra, 2, "John", "M", "9876543210"); err != nil {
                return err
            }

            // Execute the batch operation
            if err := d.Cassandra.ExecuteBatch(batchName); err != nil {
                return err
            }

            return nil
        },
    }
}
```

> ##### Check out the example to add and run migrations in GoFr: [Visit GitHub](https://github.com/gofr-dev/gofr/blob/main/examples/using-migrations/main.go)
# HTTP Authentication

Authentication is a crucial aspect of web applications, controlling access to resources based on user roles or permissions. 
It is the process of verifying a user's identity to grant access to protected resources. It ensures that only authenticated
users can perform actions or access data within an application.

GoFr offers various approaches to implement authorization.

## 1. HTTP Basic Auth
*Basic Authentication* is a simple HTTP authentication scheme where the user's credentials (username and password) are 
transmitted in the request header in a Base64-encoded format.

Basic auth is the simplest way to authenticate your APIs. It's built on
{% new-tab-link title="HTTP protocol authentication scheme" href="https://datatracker.ietf.org/doc/html/rfc7617" /%}.
It involves sending the prefix `Basic` trailed by the Base64-encoded `<username>:<password>` within the standard `Authorization` header.

### Basic Authentication in GoFr

GoFr offers two ways to implement basic authentication:

**1. Predefined Credentials**

Use `EnableBasicAuth(username, password)` to configure GoFr with pre-defined credentials.

```go
func main() {
	app := gofr.New()
    
	app.EnableBasicAuth("admin", "secret_password") // Replace with your credentials
    
	app.GET("/protected-resource", func(c *gofr.Context) (interface{}, error) {
		// Handle protected resource access 
		return nil, nil
	})

	app.Run()
}
```

**2. Custom Validation Function**

Use `EnableBasicAuthWithValidator(validationFunc)` to implement your own validation logic for credentials.
The `validationFunc` takes the username and password as arguments and returns true if valid, false otherwise.

```go
func validateUser(c *container.Container, username, password string) bool {
	// Implement your credential validation logic here 
	// This example uses hardcoded credentials for illustration only   
	return username == "john" && password == "doe123" 
} 

func main() { 
	app := gofr.New() 

	app.EnableBasicAuthWithValidator(validateUser) 

	app.GET("/secure-data", func(c *gofr.Context) (interface{}, error) { 
		// Handle access to secure data 
		return nil, nil
	})

	app.Run()
}
```

### Adding Basic Authentication to HTTP Services
This code snippet demonstrates how to add basic authentication to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("order", "https://localhost:2000",
    &service.Authentication{UserName: "abc", Password: "pass"},
)
```

## 2. API Keys Auth
*API Key Authentication* is an HTTP authentication scheme where a unique API key is included in the request header for validation against a store of authorized keys.

### Usage:
GoFr offers two ways to implement API Keys authentication.

**1. Framework Default Validation**
- GoFr's default validation can be selected using **_EnableAPIKeyAuth(apiKeys ...string)_**

```go
package main

func main() {
	// initialise gofr object
	app := gofr.New()

	app.EnableAPIKeyAuth("9221e451-451f-4cd6-a23d-2b2d3adea9cf", "0d98ecfe-4677-48aa-b463-d43505766915")

	app.GET("/customer", Customer)

	app.Run()
}
```

**2. Custom Validation Function**
- GoFr allows a custom validator function `apiKeyValidator(apiKey string) bool` for validating APIKeys and pass the func in **_EnableAPIKeyAuthWithValidator(validator)_**

```go
package main

func apiKeyValidator(c *container.Container, apiKey string) bool {
	validKeys := []string{"f0e1dffd-0ff0-4ac8-92a3-22d44a1464e4", "d7e4b46e-5b04-47b2-836c-2c7c91250f40"}

	return slices.Contains(validKeys, apiKey)
}

func main() {
	// initialise gofr object
	app := gofr.New()

	app.EnableAPIKeyAuthWithValidator(apiKeyValidator)

	app.GET("/customer", Customer)

	app.Run()
}
```

### Adding API-KEY Authentication to HTTP Services
This code snippet demonstrates how to add API Key authentication to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("http-server-using-redis", "http://localhost:8000", &service.APIKeyConfig{APIKey: "9221e451-451f-4cd6-a23d-2b2d3adea9cf"})
```

## 3. OAuth 2.0
{% new-tab-link title="OAuth" href="https://www.rfc-editor.org/rfc/rfc6749" /%} 2.0 is the industry-standard protocol for authorization. 
It focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices.

It involves sending the prefix `Bearer` trailed by the encoded token within the standard `Authorization` header.

### OAuth Authentication in GoFr

GoFr supports authenticating tokens encoded by algorithm `RS256/384/512`. 

### App level Authentication
Enable OAuth 2.0 with three-legged flow to authenticate requests

Use `EnableOAuth(jwks-endpoint,refresh_interval)` to configure GoFr with pre-defined credentials.

```go
func main() {
	app := gofr.New()

	app.EnableOAuth("http://jwks-endpoint", 20) 
    
	app.GET("/protected-resource", func(c *gofr.Context) (interface{}, error) {
		// Handle protected resource access 
		return nil, nil
	})

	app.Run()
}
```

### Adding OAuth Authentication to HTTP Services
For server-to-server communication it follows two-legged OAuth, also known as "client credentials" flow,
where the client application directly exchanges its own credentials (ClientID and ClientSecret)
for an access token without involving any end-user interaction.

This code snippet demonstrates how two-legged OAuth authentication is added to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("orders", "http://localhost:9000",
    &service.OAuthConfig{   // Replace with your credentials
        ClientID:     "0iyeGcLYWudLGqZfD6HvOdZHZ5TlciAJ",
        ClientSecret: "GQXTY2f9186nUS3C9WWi7eJz8-iVEsxq7lKxdjfhOJbsEPPtEszL3AxFn8k_NAER",
        TokenURL:     "https://dev-zq6tvaxf3v7p0g7j.us.auth0.com/oauth/token",
        Scopes:       []string{"read:order"},
        EndpointParams: map[string][]string{
            "audience": {"https://dev-zq6tvaxf3v7p0g7j.us.auth0.com/api/v2/"},
    },
})
```
# Inter-Service HTTP Calls

GoFr promotes microservice architecture and to facilitate the same, it provides the support to initialize HTTP services  
at application level using `AddHTTPService()` method.

Support for inter-service HTTP calls provide the following benefits:
1. Access to the methods from container - GET, PUT, POST, PATCH, DELETE.
2. Logs and traces for the request.
3. {% new-tab-link newtab=false title="Circuit breaking" href="/docs/advanced-guide/circuit-breaker" /%} for enhanced resilience and fault tolerance.
4. {% new-tab-link newtab=false title="Custom Health Check" href="/docs/advanced-guide/monitoring-service-health" /%} Endpoints

## Usage

### Registering a simple HTTP Service

GoFr allows registering a new HTTP service using the application method `AddHTTPService()`.  
It takes in a service name and service address argument to register the dependent service at application level.  
Registration of multiple dependent services is quite easier, which is a common use case in a microservice architecture.

> The services instances are maintained by the container.

Other provided options can be added additionally to coat the basic HTTP client with features like circuit-breaker and  
custom health check and add to the functionality of the HTTP service.  
The design choice for this was made such as many options as required can be added and are order agnostic,  
i.e. the order of the options is not important.

> Service names are to be kept unique to one service.

```go  
app.AddHTTPService(<service_name> , <service_address>)  
```  

#### Example
```go  
package main  
  
import (  
    "gofr.dev/pkg/gofr"  
)  
  
func main() {  
    // Create a new application  
    app := gofr.New()  
  
    // register a payment service which is hosted at http://localhost:9000  
    app.AddHTTPService("payment", "http://localhost:9000")  
  
    app.GET("/customer", Customer)  
  
    // Run the application  
    app.Run()  
}  
```  

### Accessing HTTP Service in handler

The HTTP service client is accessible anywhere from `gofr.Context` that gets passed on from the handler.  
Using the `GetHTTPService` method with the service name that was given at the time of registering the service,  
the client can be retrieved as shown below:

```go  
svc := ctx.GetHTTPService(<service_name>)  
```  

```go  
func Customer(ctx *gofr.Context) (interface{}, error) {  
    // Get the payment service client  
    paymentSvc := ctx.GetHTTPService("payment")  
  
    // Use the Get method to call the GET /user endpoint of payments service  
    resp, err := paymentSvc.Get(ctx, "user", nil)  
    if err != nil {  
        return nil, err  
    }  
  
    defer resp.Body.Close()  
  
    body, err := io.ReadAll(resp.Body)  
    if err != nil {  
        return nil, err  
    }  
  
    return string(body), nil  
}  
```

### Additional Configurational Options

GoFr provides its user with additional configurational options while registering http service for communication. These are:

- **APIKeyConfig** - This option allows the user to set the `API-Key` Based authentication as the default auth for downstream HTTP Service.
- **BasicAuthConfig** - This option allows the user to set basic auth (username and password) as the default auth for downstream HTTP Service.
- **OAuthConfig** - This option allows user to add `OAuth` as default auth for downstream HTTP Service.
- **CircuitBreakerConfig** - This option allows the user to configure the GoFr Circuit Breaker's `threshold` and `interval` for the failing downstream HTTP Service calls. If the failing calls exceeds the threshold the circuit breaker will automatically be enabled.
- **DefaultHeaders** - This option allows user to set some default headers that will be propagated to the downstream HTTP Service everytime it is being called.
- **HealthConfig** - This option allows user to add the `HealthEndpoint` along with `Timeout` to enable and perform the timely health checks for downstream HTTP Service.
- **RetryConfig** - This option allows user to add the maximum number of retry count if before returning error if any downstream HTTP Service fails.

#### Usage:

```go
a.AddHTTPService("cat-facts", "https://catfact.ninja",  
    &service.APIKeyConfig{APIKey: "some-random-key"},  
    
    &service.BasicAuthConfig{  
       UserName: "gofr",  
       Password: "gofr",  
  },
    
    &service.CircuitBreakerConfig{  
       Threshold: 4,  
       Interval:  1 * time.Second,  
  },  
  
   &service.DefaultHeaders{Headers: map[string]string{"key": "value"}},  
 
   &service.HealthConfig{  
       HealthEndpoint: "breeds",  
  }, 
   
   &service.OAuthConfig{  
       ClientID:       "abc",  
       ClientSecret:   "abc",  
       TokenURL:       "http://test.com",  
       Scopes:         nil,  
       EndpointParams: nil,  
  },
    
  &service.RetryConfig{
      MaxRetries: 5
  },  
)
```# Middleware in GoFr

Middleware allows you intercepting and manipulating HTTP requests and responses flowing through your application's
router. Middlewares can perform tasks such as authentication, authorization, caching etc. before
or after the request reaches your application's handler.

## CORS Middleware in GoFr
GoFr includes built-in CORS (Cross-Origin Resource Sharing) middleware to handle CORS-related headers. 
This middleware allows you to control access to your API from different origins. It automatically adds the necessary
headers to responses, allowing or restricting cross-origin requests. User can also override the default response headers
sent by GoFr by providing the suitable CORS configs.

The CORS middleware provides the following overridable configs:

- `ACCESS_CONTROL_ALLOW_ORIGIN`: Set the allowed origin(s) for cross-origin requests. By default, it allows all origins (*).
- `ACCESS_CONTROL_ALLOW_HEADERS`: Define the allowed request headers (e.g., Authorization, Content-Type).
- `ACCESS_CONTROL_ALLOW_CREDENTIALS`: Set to true to allow credentials (cookies, HTTP authentication) in requests.
- `ACCESS_CONTROL_EXPOSE_HEADERS`: Specify additional headers exposed to the client.
- `ACCESS_CONTROL_MAX_AGE`: Set the maximum time (in seconds) for preflight request caching.

> Note: GoFr automatically interprets the registered route methods and based on that sets the value of `ACCESS_CONTROL_ALLOW_METHODS`


## Adding Custom Middleware in GoFr

By adding custom middleware to your GoFr application, user can easily extend its functionality and implement 
cross-cutting concerns in a modular and reusable way.
User can use the `UseMiddleware` or `UseMiddlewareWithContainer` method on your GoFr application instance to register your custom middleware.

### Using UseMiddleware method for Custom Middleware
The UseMiddleware method is ideal for simple middleware that doesn't need direct access to the application's container.

#### Example:

```go
import (
    "net/http"

    gofrHTTP "gofr.dev/pkg/gofr/http"
)

// Define your custom middleware function
func customMiddleware() gofrHTTP.Middleware {
    return func(inner http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Your custom logic here
            // For example, logging, authentication, etc.
            
            // Call the next handler in the chain
            inner.ServeHTTP(w, r)
        })
    }
}

func main() {
    // Create a new instance of your GoFr application
    app := gofr.New()

    // Add your custom middleware to the application
    app.UseMiddleware(customMiddleware())

    // Define your application routes and handlers
    // ...

    // Run your GoFr application
    app.Run()
}
```

### Using UseMiddlewareWithContainer for Custom Middleware with Container Access

The UseMiddlewareWithContainer method allows middleware to access the application's container, providing access to
services like logging, configuration, and databases. This method is especially useful for middleware that needs access 
to resources in the container to modify request processing flow.

#### Example:

```go
import (
    "fmt"
    "net/http"
    
    "gofr.dev/pkg/gofr"
    "gofr.dev/pkg/gofr/container"
)

func main() {
    // Create a new GoFr application instance
    a := gofr.New()

    // Add custom middleware with container access
    a.UseMiddlewareWithContainer(customMiddleware)

    // Define the application's routes
    a.GET("/hello", HelloHandler)

    // Run the application
    a.Run()
}

// Define middleware with container access
func customMiddleware(c *container.Container, handler http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        c.Logger.Log("Hey! Welcome to GoFr")
        
        // Continue with the request processing
        handler.ServeHTTP(w, r)
    })
}

// Sample handler function
func HelloHandler(c *gofr.Context) (interface{}, error) {
    name := c.Param("name")
    if name == "" {
        c.Log("Name came empty")
        name = "World"
    }

    return fmt.Sprintf("Hello %s!", name), nil
}
```

# Overriding Default

GoFr allows overriding default behavior of its features.

## Raw response format

GoFr by default wraps a handler's return value and assigns it to the `data` field in a response.

### Example

```go
package main

import "gofr.dev/pkg/gofr"

type user struct {
  ID   int    `json:"id"`
  Name string `json:"name"`
}

func main() {
  app := gofr.New()

  app.GET("/users", func(ctx *gofr.Context) (interface{}, error) {

    users := []user{{ID: 1, Name: "Daria"}, {ID: 2, Name: "Ihor"}}

    return users, nil
  })

  app.Run()
}
```

Response example:
```json
{
  "data": [
    {
      "id": 1,
      "name": "Daria"
    },
    {
      "id": 2,
      "name": "Ihor"
    }
  ]
}
```

If you want to have a raw response structure - wrap it in `response.Raw`:
```go
app.GET("/users", func(ctx *gofr.Context) (interface{}, error) {

    users := []user{{ID: 1, Name: "Daria"}, {ID: 2, Name: "Ihor"}}

    return response.Raw{Data: users}, nil	
})
```

Response example:
```json
[
  {
    "id": 1,
    "name": "Daria"
  },
  {
    "id": 2,
    "name": "Ihor"
  }
]
```

## Favicon.ico

By default, GoFr load its own `favicon.ico` present in root directory for an application. To override `favicon.ico` user
can place its custom icon in the **static** directory of its application.

> NOTE: The custom favicon should also be named as `favicon.ico` in the static directory of application.
# Remote Log Level Change

GoFr makes it easy to adjust the details captured in the application's logs, even while it's running!

This feature allows users to effortlessly fine-tune logging levels without the need for redeployment, enhancing the monitoring and debugging experience.
It is facilitated through simple configuration settings.

## How it helps?

- **Effortless Adjustments:** Modify the log level anytime without restarting the application. This is especially helpful during troubleshooting.
- **Enhanced Visibility:** Easily switch to a more detailed log level (e.g., `DEBUG`) to gain deeper insights into specific issues,
  and then switch back to a less detailed level (e.g., `INFO`) for regular operation.
- **Improved Performance:** Generating a large number of logs can overwhelm the logging system, leading to increased I/O operations and resource consumption,
  changing to Warn or Error Level reduces the number of logs, and enhancing performance.

## Configuration

To enable remote log level update, users need to specify the following configuration parameter:

```dotenv
REMOTE_LOG_URL=<URL to user's remote log level endpoint> (e.g., https://log-service.com/log-levels)
REMOTE_LOG_FETCH_INTERVAL=<Interval in seconds> (default: 15)
```

- **REMOTE_LOG_URL:** Specifies the URL of the remote log level endpoint.
- **REMOTE_LOG_FETCH_INTERVAL:** Defines the time interval (in seconds) at which GoFr fetches log level configurations from the endpoint.

> NOTE: If not provided the default interval between the request to fetch log level is **15 seconds**.

## Remote Log Level Endpoint

The remote log level endpoint should return a JSON response in the following format:

```json
{
  "data": {
    "serviceName": "test-service",
    "logLevel": "DEBUG"
  }
}
```

- **serviceName:** Identifies the service for which log levels are configured.
- **logLevel:** The new log level user want to set for the specified service.

GoFr parses this response and adjusts log levels based on the provided configurations.
# Setting Custom Response Headers

In GoFr, you can customize HTTP response headers using the `Response` struct, allowing you to add extra information to 
responses sent from your application. This feature can be useful for adding metadata, such as custom headers, security 
policies, or other contextual information, to improve the client-server communication.

## Using the Response Struct

To use custom headers in your handler, create and return a Response object within the handler function. This object 
should contain the response data along with a Headers map for any custom headers you wish to add.

### Example:

Below is an example showing how to use the Response struct in a GoFr handler. In this case, the `HelloHandler` function 
returns a greeting message along with two custom headers: X-Custom-Header and X-Another-Header.

```go
package main

import (
	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/http/response"
)

func main() {
	// Create a new application
	a := gofr.New()

	// Add the route
	a.GET("/hello", HelloHandler)

	// Run the application
	a.Run()
}

func HelloHandler(c *gofr.Context) (interface{}, error) {
	name := c.Param("name")
	if name == "" {
		c.Log("Name came empty")
		name = "World"
	}

	headers := map[string]string{
		"X-Custom-Header":  "CustomValue",
		"X-Another-Header": "AnotherValue",
	}

	return response.Response{
		Data:    "Hello World from new Server",
		Headers: headers,
	}, nil
}
```

This functionality offers a convenient, structured way to include additional response information without altering the 
core data payload.# Cron job scheduling

Cron is a task scheduler that allows user to automate commands or scripts to 
run at specific times, dates, or intervals. This makes cron a powerful tool for system administrators and developers who 
want to automate repetitive tasks.

What can users automate with cron?

- **System maintenance**: Cron can be used to schedule regular backups, update software packages, or clean up temporary files.
- **Data processing**: Users can use cron to download data from the internet at specific times, process it, and generate reports.
- **Sending notifications**: Cron can be used to trigger emails or other notifications based on events or system logs.

Basically, any task that can be expressed as a command or script can be automated with cron.

Writing a cron job!
On Linux like systems cron jobs can be added by adding a line to the crontab file, specifying the schedule and the command
that needs to be run at that schedule. The cron schedule is expressed in the following format:

`minute hour day_of_month month day_of_week`

GoFr also allows an optional field for `second` as first part in the schedule format, like in the following format:

`second minute hour day_of_month month day_of_week`

Each field can take a specific value or combination of values to define the schedule. Users can use special characters like 
`*` (asterisk) to represent **any** value and `,` (comma) to separate multiple values. It also supports `0-n` to define a
range of values for which the cron should run and `*/n` to define number of times the cron should run. Here n is an integer.

## Adding cron jobs in GoFr applications
Adding cron jobs to GoFr applications is made easy with a simple injection of user's function to the cron table maintained
by the GoFr. The minimum time difference between cron job's two consecutive runs is a minute as it is the least significant
scheduling time parameter.

Cron job with generic format:
```go
app.AddCronJob("* * * * *", "job-name", func(ctx *gofr.Context) {
	// the cron job that needs to be executed at every minute
})
```
Cron job with optional second in format: 
```go
app.AddCronJob("* * * * * *", "job-name", func(ctx *gofr.Context) {
    // the cron job that needs to be executed at every second
})
```
The `AddCronJob` methods takes three argumentsâ€”a cron schedule, the cron job name(for tracing) and the set of statements 
that are to be executed at the given schedule.

### Example

```go
package main

import (
	"time"
	
	"gofr.dev/pkg/gofr"
)

func main() {
    app := gofr.New()

	// Run the cron job every 5 hours(*/5)
	app.AddCronJob("* */5 * * *", "", func(ctx *gofr.Context) {
		ctx.Logger.Infof("current time is %v", time.Now())
	})
	
	// Run the cron job every 10 seconds(*/10)
	app.AddCronJob("*/10 * * * * *", "", func(ctx *gofr.Context) {
		ctx.Logger.Infof("current time is %v", time.Now())
	})

	app.Run()
}
```

> #### Check out the example on how to add cron jobs in GoFr: [Visit GitHub](https://github.com/gofr-dev/gofr/blob/main/examples/using-cron-jobs/main.go)
# Websockets

WebSockets provide a full-duplex communication channel over a single, long-lived connection, making them ideal for 
real-time applications like chat, notifications, and live updates. GoFr provides a convenient way to integrate websockets
into your application. By leveraging GoFr's WebSocket support and customizable upgrader options,
you can efficiently manage real-time communication in your applications.

## Usage in GoFr

Here is a simple example to set up a WebSocket server in GoFr:

```go
package main

import (
	"gofr.dev/pkg/gofr"
)

func main() {
	app := gofr.New()

	app.WebSocket("/ws", WSHandler)

	app.Run()
}

func WSHandler(ctx *gofr.Context) (interface{}, error) {
	var message string

	err := ctx.Bind(&message)
	if err != nil {
		ctx.Logger.Errorf("Error binding message: %v", err)
		return nil, err
	}

	ctx.Logger.Infof("Received message: %s", message)

	return message, nil
}
```

## Configuration Options
GoFr allows you to customize the WebSocket upgrader with several options. You can set these options using the 
`websocket.NewWSUpgrader` function. Here is the list of options you can apply to your websocket upgrader using GoFr.

- `HandshakeTimeout (WithHandshakeTimeout)`: Sets the handshake timeout.
- `ReadBufferSize (WithReadBufferSize)`: Sets the size of the read buffer.
- `WriteBufferSize (WithWriteBufferSize)`: Sets the size of the write buffer.
- `Subprotocols (WithSubprotocols)`: Sets the supported sub-protocols.
- `Error (WithError)`:  Sets a custom error handler.
- `CheckOrigin (WithCheckOrigin)`: Sets a custom origin check function.
- `Compression (WithCompression)`:  Enables compression.

## Example:
You can configure the Upgrader by creating a chain of option functions provided by GoFr.

```go
package main

import (
	"time"
	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/websocket"
)

func main() {
	app := gofr.New()

	wsUpgrader := websocket.NewWSUpgrader(
		websocket.WithHandshakeTimeout(5 * time.Second), // Set handshake timeout
		websocket.WithReadBufferSize(2048),              // Set read buffer size
		websocket.WithWriteBufferSize(2048),             // Set write buffer size
		websocket.WithSubprotocols("chat", "binary"),    // Specify subprotocols
		websocket.WithCompression(),                     // Enable compression
	)

	app.OverrideWebSocketUpgrader(wsUpgrader)

	app.WebSocket("/ws", WSHandler)

	app.Run()
}

func WSHandler(ctx *gofr.Context) (interface{}, error) {
	var message string

	err := ctx.Bind(&message)
	if err != nil {
		ctx.Logger.Errorf("Error binding message: %v", err)
		return nil, err
	}

	ctx.Logger.Infof("Received message: %s", message)

	err = ctx.WriteMessageToSocket("Hello! GoFr")
	if err != nil {
		return nil, err
	}

	return message, nil
}
```
> #### Check out the example on how to read/write through a WebSocket in GoFr: [Visit GitHub](https://github.com/gofr-dev/gofr/blob/main/examples/using-web-socket/main.go)
# Add REST Handlers

GoFr simplifies the process of implementing CRUD (Create, Read, Update, Delete) operations by enabling the automatic generation of handlers directly from Go structs.
This feature eliminates the need for writing repetitive boilerplate code, allowing developers to focus on application logic.

## Default Behaviour

If the custom handlers ain't implemented on the struct, GoFr provides default handlers for each CRUD operation. These handlers handle basic database interactions:

- **Create**: `/entity` Inserts a new record based on data provided in a JSON request body.
- **Read**:
  - **GET**:  `/entity` Retrieves all entities of the type specified by the struct.
  - **GET**:  `/entity/{id}` Retrieves a specific entity identified by the {id} path parameter.
- **Update**: `/entity/{id}` Updates an existing record identified by the {id} path parameter, based on data provided in a JSON request body.
- **Delete**  `/entity/{id}` Deletes an existing record identified by the {id} path parameter.

**NOTE**: The registered routes will have the same name as the given struct, but if you want to change route name, you can implement `RestPath` method in the struct:
```go
type userEntity struct {
	Id         int    `json:"id"`
	Name       string `json:"name"`
	Age        int    `json:"age"`
	IsEmployed bool   `json:"isEmployed"`
}

func (u *userEntity) RestPath() string {
	return "users"
}
```

## Overriding Default Handlers

While the default handlers provide basic functionality, user might want to customize their behavior for specific use cases. 
The AddRESTHandlers feature allows user to override these handlers by implementing methods within the struct itself.

## Database Table Name
By default, GoFr assumes the struct name in snake-case matches the database table name for querying data. For example, `UserEntity` struct matches `user_entity` database table, `cardConfig` struct matches `card_config` database table, etc.
To change table name, you need to implement `TableName` method in the struct:
```go
type userEntity struct {
	Id         int    `json:"id"`
	Name       string `json:"name"`
	Age        int    `json:"age"`
	IsEmployed bool   `json:"isEmployed"`
}

func (u *userEntity) TableName() string {
	return "user"
}
```

## Adding Database Constraints
By default, GoFr assumes to have manual insertion of id for a given struct, but to support sql constraints like `auto-increment`,
`not-null` user can use the `sql` tag while declaring the struct fields.

```go
type user struct {
	ID         int    `json:"id"  sql:"auto_increment"`
	Name       string `json:"name"  sql:"not_null"`
	Age        int    `json:"age"`
	IsEmployed bool   `json:"isEmployed"`
}
```

Now when posting data for the user struct, the `Id` we be auto-incremented and the `Name` will be a not-null field in table.

## Benefits of Adding REST Handlers of GoFr

1. Reduced Boilerplate Code: Eliminate repetitive code for CRUD operations, freeing user to focus on core application logic.
2. Consistency: Ensures consistency in CRUD operations across different entities by using a standardized approach.
3. Flexibility: Allows developers to customize CRUD behavior as per application requirements, providing flexibility and extensibility.

## Example

```go
package main

import (
	"gofr.dev/examples/using-crud-from-struct/migrations"
	"gofr.dev/pkg/gofr"
)

type user struct {
	Id         int    `json:"id"`
	Name       string `json:"name"`
	Age        int    `json:"age"`
	IsEmployed bool   `json:"isEmployed"`
}

// GetAll : User can overwrite the specific handlers by implementing them like this
func (u *user) GetAll(c *gofr.Context) (interface{}, error) {
	return "user GetAll called", nil
}

func main() {
	// Create a new application
	a := gofr.New()

	// Add migrations to run
	a.Migrate(migrations.All())

	// AddRESTHandlers creates CRUD handles for the given entity
	err := a.AddRESTHandlers(&user{})
	if err != nil {
		return
	}

	// Run the application
	a.Run()
}
```

In this example, we define a user struct representing a database entity. The `GetAll` method in the provided code demonstrates how to override the default behavior for retrieving all entities.
This method can be used to implement custom logic for filtering, sorting, or retrieving additional data along with the entities.


## Few Points to Consider:

**1. Passing Struct by Reference**

The struct should always be passed by reference in the method `AddRESTHandlers`.

**2. Field Naming Convention**

GoFr assumes that struct fields in snake_case match the database column names.

* For example, the `IsEmployed` field in the struct matches the `is_employed` column in the database.
* Similarly, the `Age` field matches the `age` column.

**3. Primary Key**

The first field of the struct is typically used as the primary key for data operations. However, this behavior can be customized using GoFr's features.

**4. Datatype Conversions**

| Go Type | SQL Type | Description |
|---|---|---|
| `uuid.UUID` (from `github.com/google/uuid` or `github.com/satori/go.uuid`) | `CHAR(36)` or `VARCHAR(36)` | UUIDs are typically stored as 36-character strings in SQL databases. |
| `string` | `VARCHAR(n)` or `TEXT` | Use `VARCHAR(n)` for fixed-length strings, while `TEXT` is for longer, variable-length strings. |
| `int`, `int32`, `int64`, `uint`, `uint32`, `uint64` | `INT`, `BIGINT`, `SMALLINT`, `TINYINT`, `INTEGER` | Use `INT` for general integer values, `BIGINT` for large values, and `SMALLINT` or `TINYINT` for smaller ranges. |
| `bool` | `BOOLEAN` or `TINYINT(1)` | Use `BOOLEAN` (supported by most SQL databases like PostgreSQL, MySQL) or `TINYINT(1)` in MySQL (where `0` is false, and `1` is true). |
| `float32`, `float64` | `FLOAT`, `DOUBLE`, `DECIMAL` | Use `DECIMAL` for precise decimal numbers (e.g., financial data), `FLOAT` or `DOUBLE` for approximate floating-point numbers. |
| `time.Time` | `DATE`, `TIME`, `DATETIME`, `TIMESTAMP` | Use `DATE` for just the date, `TIME` for the time of day, and `DATETIME` or `TIMESTAMP` for both date and time. |
> #### Check out the example on how to add REST Handlers in GoFr: [Visit Github](https://github.com/gofr-dev/gofr/tree/main/examples/using-add-rest-handlers)# Connecting MySQL

Just like Redis GoFr also supports connection to SQL(MySQL and Postgres) databases based on configuration variables.

## Setup

Users can run MySQL and create a database locally using the following Docker command:

```bash
docker run --name gofr-mysql -e MYSQL_ROOT_PASSWORD=root123 -e MYSQL_DATABASE=test_db -p 3306:3306 -d mysql:8.0.30
```

Access `test_db` database and create table customer with columns `id` and `name`

```bash
docker exec -it gofr-mysql mysql -uroot -proot123 test_db -e "CREATE TABLE customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL);"
```

Now the database with table is ready, we can connect our GoFr server to MySQL

## Configuration & Usage

After adding MySQL configs `.env` will be updated to the following.

```dotenv
# configs/.env
APP_NAME=test-service
HTTP_PORT=9000

REDIS_HOST=localhost
REDIS_PORT=6379

DB_HOST=localhost
DB_USER=root
DB_PASSWORD=root123
DB_NAME=test_db
DB_PORT=3306
DB_DIALECT=mysql
DB_CHARSET=

# DB_CHARSET: The character set for database connection (default: utf8).
# The `DB_CHARSET` defaults to utf8, but setting it to utf8mb4 is recommended if you need full Unicode support,
# including emojis and special characters.
```

Now in the following example, we'll store customer data using **POST** `/customer` and then use **GET** `/customer` to retrieve the same.
We will be storing the customer data with `id` and `name`.

After adding code to add and retrieve data from MySQL datastore, `main.go` will be updated to the following.

```go
package main

import (
	"errors"

	"github.com/redis/go-redis/v9"

	"gofr.dev/pkg/gofr"
)

type Customer struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

func main() {
	// initialise gofr object
	app := gofr.New()

	app.GET("/redis", func(ctx *gofr.Context) (interface{}, error) {
		// Get the value using the Redis instance

		val, err := ctx.Redis.Get(ctx.Context, "test").Result()
		if err != nil && !errors.Is(err, redis.Nil) {
			// If the key is not found, we are not considering this an error and returning ""
			return nil, err
		}

		return val, nil
	})

	app.POST("/customer/{name}", func(ctx *gofr.Context) (interface{}, error) {
		name := ctx.PathParam("name")

		// Inserting a customer row in database using SQL
		_, err := ctx.SQL.ExecContext(ctx, "INSERT INTO customers (name) VALUES (?)", name)

		return nil, err
	})

	app.GET("/customer", func(ctx *gofr.Context) (interface{}, error) {
		var customers []Customer

		// Getting the customer from the database using SQL
		rows, err := ctx.SQL.QueryContext(ctx, "SELECT * FROM customers")
		if err != nil {
			return nil, err
		}

		for rows.Next() {
			var customer Customer
			if err := rows.Scan(&customer.ID, &customer.Name); err != nil {
				return nil, err
			}

			customers = append(customers, customer)
		}

		// return the customer
		return customers, nil
	})

	app.Run()
}
```

To update the database with the customer data access use through this curl command through terminal

```bash
# here abc and xyz after /customer are the path parameters
curl --location --request POST 'http://localhost:9000/customer/abc'

curl --location --request POST 'http://localhost:9000/customer/xyz'
```
Now when we access {% new-tab-link title="http://localhost:9000/customer" href="http://localhost:9000/customer" /%} we should see the following output

```json
{
  "data": [
    {
      "id": 1,
      "name": "abc"
    },
    {
      "id": 2,
      "name": "xyz"
    }
  ]
}
```
# Prerequisite

- Go 1.21 or above.
  To check Go version use the following command `go version`.

- Prior familiarity with Golang syntax is essential. {% new-tab-link title="Golang Tour" href="https://tour.golang.org/" /%} is highly recommended as it has an excellent guided tour.

## Write your first GoFr API

Let's start by initializing the {% new-tab-link title="go module" href="https://go.dev/ref/mod" /%} by using the following command.

```bash
go mod init github.com/example
```

Add {% new-tab-link title="gofr" href="https://github.com/gofr-dev/gofr" /%} package to the project using the following command.

```bash
go get gofr.dev
```

This code snippet showcases the creation of a simple GoFr application that defines a route and serves a response. 
You can add this code to your main.go file.

```go
package main

import "gofr.dev/pkg/gofr"

func main() {
    // initialise gofr object
    app := gofr.New()

    // register route greet
    app.GET("/greet", func(ctx *gofr.Context) (interface{}, error) {

        return "Hello World!", nil
    })

    // Runs the server, it will listen on the default port 8000.
    // it can be over-ridden through configs
   app.Run()
}
```

Before starting the server, run the following command in your terminal to ensure you have downloaded and synchronized all required dependencies for your project.

`go mod tidy`

Once the dependencies are synchronized, start the GoFr server using the following command:

`go run main.go`

This would start the server at 8000 port, `/greet` endpoint can be accessed from your browser at {% new-tab-link title="http://localhost:8000/greet" href="http://localhost:8000/greet" /%} , you would be able to see the output as following with _Status Code 200_ as per REST Standard.

```json
{ "data": "Hello World!" }
```

## Understanding the example

The `hello-world` server involves three essential steps:

1. **Creating GoFr Server:**

   When `gofr.New()` is called, it initializes the framework and handles various setup tasks like initializing logger, metrics, datasources, etc. based on the configs.

   _This single line is a standard part of all GoFr servers._

2. **Attaching a Handler to a Path:**

   In this step, the server is instructed to associate an HTTP request with a specific handler function. This is achieved through `app.GET("/greet", HandlerFunction)`, where _GET /greet_ maps to HandlerFunction. Likewise, `app.POST("/todo", ToDoCreationHandler)` links a _POST_ request to the `/todo` endpoint with _ToDoCreationHandler_.

   **Good To Know**

> In Go, functions are first-class citizens, allowing easy handler definition and reference.
> HTTP Handler functions should follow the `func(ctx *gofr.Context) (interface{}, error)` signature.
> They take a context as input, returning two values: the response data and an error (set to `nil` when there is no error).

GoFr {% new-tab-link  newtab=false title="context" href="/docs/references/context" /%} `ctx *gofr.Context` serves as a wrapper for requests, responses, and dependencies, providing various functionalities.

3. **Starting the server**

   When `app.Run()` is called, it configures, initiates and runs the HTTP server, middlewares. It manages essential features such as routes for health check endpoints, metrics server, favicon etc. It starts the server on the default port 8000.
# GoFr Context

GoFr context is an object injected by the GoFr handler. It contains all the request-specific data, for each
request-response cycle a new context is created. The request can be either an HTTP request, GRPC call or
a message from Pub-Sub.
GoFr Context also embeds the **_container_** which maintains all the dependencies like databases, logger, HTTP service clients,
metrics manager, etc. This reduces the complexity of the application as users don't have to maintain and keep track of
all the dependencies by themselves.

GoFr context is an extension of the go context, providing a wrapper around the request and response providing
user access to dependencies.

# Usage

## Reading HTTP requests

`ctx.Request` can be used to access the underlying request which provides the following methods to access different
parts of the request.

- `Context()` - to access the context associated with the incoming request
  ```go
  ctx.Request.Context()
  ```
- `Param(string)` - to access the query parameters present in the request, it returns the value of the key provided
  ```go
  // Example: Request is /configs?key1=value1&key2=value2
  value := ctx.Request.Param("key1")
  // value = "value1"
  ```
- `PathParam(string)` - to retrieve the path parameters
  ```go
  // Consider the path to be /employee/{id}
  id := ctx.Request.PathParam("id")
  ```
- `Bind(interface{})` - to access a decoded format of the request body, the body is mapped to the interface provided

  ```go
  // incoming request body is
  // {
  //    "name" : "trident",
  //    "category" : "snacks"
  // }

   type product struct{
      Name string `json:"name"`
      Category string `json:"category"`
   }

  var p product
  ctx.Bind(&p)
  // the Bind() method will map the incoming request to variable p
  ```
  
- `Binding multipart-form data / urlencoded form data ` 
  - To bind multipart-form data or url-encoded form, you can use the Bind method similarly. The struct fields should be tagged appropriately 
    to map the form fields to the struct fields. The supported content types are `multipart/form-data` and `application/x-www-form-urlencoded`
    
    ```go
    type Data struct {
    Name string `form:"name"`

    Compressed file.Zip `file:"upload"`

    FileHeader *multipart.FileHeader `file:"file_upload"`
    }
    ```

  - The `form` tag is used to bind non-file fields.
  - The `file` tag is used to bind file fields. If the tag is not present, the field name is used as the key.


- `HostName()` - to access the host name for the incoming request
  ```go
    // for example if request is made from xyz.com
    host := ctx.Request.HostName()
    // the host would be http://xyz.com
    // Note: the protocol if not provided in the headers will be set to http by default
  ```
- `Params(string)` - to access all query parameters for a given key returning slice of strings.
  ```go 
    // Example: Request is /search?category=books,electronics&category=tech
    values := ctx.Request.Params("category")
    // values = []string{"books", "electronics", "tech"}
  ```

## Accessing dependencies

GoFr context embeds the container object which provides access to
all the injected dependencies by the users. Users can access the fields and methods provided
by the **_container_**.
# Testing REST APIs with GoFr

Testing REST APIs ensures that your endpoints function correctly under various conditions. This guide demonstrates how to write tests for GoFr-based REST APIs.

## Mocking Databases in GoFr

Mocking databases allows for isolated testing by simulating various scenarios. GoFr's built-in mock container supports, not only SQL databases, but also extends to other data stores, including Redis, Cassandra, Key-Value stores, MongoDB, and ClickHouse.

## Example of Unit Testing a REST API Using GoFr

Below is an example of how to test, say the `Add` method of a handler that interacts with a SQL database.

Hereâ€™s an `Add` function for adding a book to the database using GoFr:

```go
// main.go
package main

import (
	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/http"
)

type Book struct {
	Id    int    `json:"id"`
	ISBN  int    `json:"isbn"`
	Title string `json:"title"`
}

func Add(ctx *gofr.Context) (interface{}, error) {
	var book Book

	if err := ctx.Bind(&book); err != nil {
		ctx.Logger.Errorf("error in binding: %v", err)
		return nil, http.ErrorInvalidParam{Params: []string{"body"}}
	}

	// we assume the `id` column in the database is set to auto-increment.
	res, err := ctx.SQL.ExecContext(ctx, `INSERT INTO books (title, isbn) VALUES (?, ?)`, book.Title, book.ISBN)
	if err != nil {
		return nil, err
	}

	id, err := res.LastInsertId()
	if err != nil {
		return nil, err
	}

	return id, nil
}

func main() {
	// initialise gofr object
	app := gofr.New()

	app.POST("/book", Add)

	// Run the application
	app.Run()
}

```

Hereâ€™s how to write tests using GoFr:

```go
// main_test.go
package main

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/stretchr/testify/assert"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/container"
	gofrHttp "gofr.dev/pkg/gofr/http"
)

func TestAdd(t *testing.T) {
	type gofrResponse struct {
		result interface{}
		err  error
	}

	// NewMockContainer provides mock implementations for various databases including:
	// Redis, SQL, ClickHouse, Cassandra, MongoDB, and KVStore.
	// These mock can be used to define database expectations in unit tests,
	// similar to the SQL example demonstrated here.
	mockContainer, mock := container.NewMockContainer(t)

	ctx := &gofr.Context{
		Context:   context.Background(),
		Request:   nil,
		Container: mockContainer,
	}

	tests := []struct {
		name             string
		requestBody      string
		mockExpect       func()
		expectedResponse interface{}
	}{
		{
			name:        "Error while Binding",
			requestBody: `title":"Book Title","isbn":12345}`,
			mockExpect: func() {
			},
			expectedResponse: gofrResponse{
				nil,
				gofrHttp.ErrorInvalidParam{Params: []string{"body"}}},
		},
		{
			name:        "Successful Insertion",
			requestBody: `{"title":"Book Title","isbn":12345}`,
			mockExpect: func() {
				mock.SQL.
					EXPECT().
					ExecContext(ctx, `INSERT INTO books (title, isbn) VALUES (?, ?)`, "Book Title", 12345).
					Return(sqlmock.NewResult(12, 1), nil)
			},
			expectedResponse: gofrResponse{
				int64(12),
				nil,
			},
		},
		{
			name:        "Error on Insertion",
			requestBody: `{"title":"Book Title","isbn":12345}`,
			mockExpect: func() {
				mock.SQL.
					EXPECT().
					ExecContext(ctx, `INSERT INTO books (title, isbn) VALUES (?, ?)`, "Book Title", 12345).
					Return(nil, sql.ErrConnDone)
			},
			expectedResponse: gofrResponse{
				nil,
				sql.ErrConnDone},
		},
		{
			name:        "Error while fetching LastInsertId",
			requestBody: `{"title":"Book Title","isbn":12345}`,
			mockExpect: func() {
				mock.SQL.
					EXPECT().
					ExecContext(ctx, `INSERT INTO books (title, isbn) VALUES (?, ?)`, "Book Title", 12345).
					Return(sqlmock.NewErrorResult(errors.New("mocked result error")), nil)
			},
			expectedResponse: gofrResponse{
				nil,
				errors.New("mocked result error")},
		},
	}

	for i, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.mockExpect()

			var req *http.Request

			req = httptest.NewRequest(
				http.MethodPost,
				"/book",
				bytes.NewBuffer([]byte(tt.requestBody)),
			)

			req.Header.Set("Content-Type", "application/json")

			request := gofrHttp.NewRequest(req)

			ctx.Request = request

			val, err := Add(ctx)

			response := gofrResponse{val, err}

			assert.Equal(t, tt.expectedResponse, response, "TEST[%d], Failed.\n%s", i, tt.name)
		})
	}
}
```
### Summary

- **Mocking Database Interactions**: Use GoFr mock container to simulate database interactions.
- **Define Test Cases**: Create table-driven tests to handle various scenarios.
- **Run and Validate**: Ensure that your tests check for expected results, and handle errors correctly.

This approach guarantees that your database interactions are tested independently, allowing you to simulate different responses and errors hassle-free.
# Circuit Breaker in HTTP Communication

Calls to remote resources and services can fail due to temporary issues like slow network connections or timeouts, service unavailability. While transient faults can be mitigated using the "Retry pattern", there are cases where continual retries are futile, such as during severe service failures.

In such scenarios, it's crucial for applications to recognize when an operation is unlikely to succeed and handle the failure appropriately rather than persistently retrying. Indiscriminate use of HTTP retries can even lead to unintentional denial-of-service attacks within the software itself, as multiple clients may flood a failing service with retry attempts.

To prevent this, a defense mechanism like the circuit breaker pattern is essential. Unlike the "Retry pattern" which aims to eventually succeed, the circuit breaker pattern focuses on preventing futile operations. While these patterns can be used together, it's vital for the retry logic to be aware of the circuit breaker's feedback and cease retries if the circuit breaker indicates a non-transient fault.

GoFr inherently provides the functionality, it can be enabled by passing circuit breaker configs as options to `AddHTTPService()` method.

## Usage

```go
package main

import (
	"time"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/service"
)

func main() {
	// Create a new application
	app := gofr.New()

	app.AddHTTPService("order", "https://order-func",
		&service.CircuitBreakerConfig{
		    // Number of consecutive failed requests after which circuit breaker will be enabled
			Threshold: 4,
			// Time interval at which circuit breaker will hit the aliveness endpoint.
			Interval:  1 * time.Second,
		},
	)

	app.GET("/order", Get)

	// Run the application
	app.Run()
}
```

Circuit breaker state changes to open when number of consecutive failed requests increases the threshold.
When it is in open state, GoFr makes request to the aliveness endpoint (default being - /.well-known/alive) at an equal interval of time provided in config.

> ##### Check out the example of an inter-service HTTP communication along with circuit-breaker in GoFr: [Visit Github](https://github.com/gofr-dev/gofr/blob/main/examples/using-http-service/main.go)# Custom Spans In Tracing

GoFr's built-in tracing provides valuable insights into application's behavior. However, sometimes you might need 
even more granular details about specific operations within your application. This is where `custom spans` can be used.

## How it helps?
By adding custom spans in traces to your requests, you can:

- **Gain granular insights:** Custom spans allow you to track specific operations or functions within your application, 
     providing detailed performance data.
- **Identify bottlenecks:** Analyzing custom spans helps to pinpoint areas of your code that may be causing 
      performance bottlenecks or inefficiencies.
- **Improve debugging:** Custom spans enhance the ability to debug issues by providing visibility into the execution 
      flow of an application.

## Usage

To add a custom trace to a request, GoFr context provides `Trace()` method, which takes the name of the span as an argument 
and returns a trace.Span. 

```go
func MyHandler(c context.Context) error {
    span := c.Trace("my-custom-span")
    defer span.Close()
    
    // Do some work here
    return nil
}
```

In this example, **my-custom-span** is the name of the custom span that is added to the request.
The defer statement ensures that the span is closed even if an error occurs to ensure that the trace is properly recorded.

> ##### Check out the example of creating a custom span in GoFr: [Visit Github](https://github.com/gofr-dev/gofr/blob/main/examples/http-server/main.go#L58)
# gRPC
We have already seen how GoFr can help ease the development of HTTP servers, but there are
cases where performance is primarily required sacrificing flexibility. In these types of 
scenarios gRPC protocol comes into picture. {% new-tab-link title="gRPC" href="https://grpc.io/docs/what-is-grpc/introduction/" /%} is an open-source RPC(Remote Procedure Call)
framework initially developed by Google. 

## Prerequisites
- Install the `protoc` protocol buffer compilation
    - Linux, using `apt` or `apt-get`
        ```shell
        $ apt install -y protobuf-compiler
        $ protoc --version  # Ensure compiler version is 3+
        ```
    - macOS, using Homebrew
        ```shell
        $ brew install protobuf
        $ protoc --version  # Ensure compiler version is 3+  
        ```
- Install **Go Plugins** for protocol compiler:
    1. Install protocol compiler plugins for Go
       ```shell
       $ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
       $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
       ```
    2. Update `PATH` for `protoc` compiler to find the plugins:
       ```shell
       $ export PATH="$PATH:$(go env GOPATH)/bin"
       ```
       
## Creating protocol buffers
For a detailed guide, please take a look at the {% new-tab-link title="Tutorial" href="https://grpc.io/docs/languages/go/basics/" /%} at official gRPC docs.

We need to create a `customer.proto` file to define our service and the RPC methods that the service provides.
```protobuf
// Indicates the protocol buffer version that is being used
syntax = "proto3";
// Indicates the go package where the generated file will be produced
option go_package = "";

service CustomerService {
  // ...
}
```
Inside the service one can define all the `rpc` methods, specifying the request and responses types.
```protobuf
service CustomerService {
  // GetCustomer is a rpc method to get customer data using specific filters
  rpc GetCustomer(CustomerFilter) returns(CustomerData) {}
}
```
The `CustomerFilter` and `CustomerData` are two types of messages that will be exchanged between server
and client. Users must define those for protocol buffer to serialize them when making a remote procedure call.
```protobuf
syntax = "proto3";

message CustomerFilter {
  int64 id = 1;
  string name = 2;
  // other fields that can be passed
}

message CustomerData {
  int64 id = 1;
  string name = 2;
  string address = 3;
  // other customer related fields
}
```

Now run the following command to generate go code using the Go gRPC plugins:
```shell
protoc \
--go_out=. \
--go_opt=paths=source_relative \
--go-grpc_out=. \
--go-grpc_opt=paths=source_relative \ 
customer.proto
```
Above command will generate two files `customer.pb.go` and `customer_grpc.pb.go` and these contain necessary code to perform RPC calls.
In `customer.pb.go` you can find `CustomerService` interface-
```go
// CustomerServiceServer is the server API for CustomerService service.
type CustomerServiceServer interface {
    GetCustomer(context.Context, *CustomerFilter) (*CustomerData, error)
}
```
User needs to implement this interface to serve the content to the client calling the method.
```go
package customer

import (
    "context"
)

type Handler struct {
    // required fields to get the customer data
}

func (h *Handler) GetCustomer(ctx context.Context, filter *CustomerFilter) (*CustomerData, error) {
	// get the customer data and handler error
	return data, nil
}
```

Lastly to register the gRPC service to the GoFr server, user can call the `RegisterCustomerServiceServer` in `customer_grpc.pb.go`
to register the service giving GoFr app and the Handler struct.
```go
package main

import (
	"gofr.dev/pkg/gofr"
	"gofr.dev/examples/grpc-server/customer"
)

func main() {
	app := gofr.New()

	customer.RegisterCustomerServiceServer(app, customer.Handler{})

	app.Run()
}
```
>Note: By default, gRPC server will run on port 9000, to customize the port users can set `GRPC_PORT` config in the .env

> ##### Check out the example of setting up a gRPC server in GoFr: [Visit GitHub](https://github.com/gofr-dev/gofr/blob/main/examples/grpc-server/main.go)
# HTTP Authentication

Authentication is a crucial aspect of web applications, controlling access to resources based on user roles or permissions. 
It is the process of verifying a user's identity to grant access to protected resources. It ensures that only authenticated
users can perform actions or access data within an application.

GoFr offers various approaches to implement authorization.

## 1. HTTP Basic Auth
*Basic Authentication* is a simple HTTP authentication scheme where the user's credentials (username and password) are 
transmitted in the request header in a Base64-encoded format.

Basic auth is the simplest way to authenticate your APIs. It's built on
{% new-tab-link title="HTTP protocol authentication scheme" href="https://datatracker.ietf.org/doc/html/rfc7617" /%}.
It involves sending the prefix `Basic` trailed by the Base64-encoded `<username>:<password>` within the standard `Authorization` header.

### Basic Authentication in GoFr

GoFr offers two ways to implement basic authentication:

**1. Predefined Credentials**

Use `EnableBasicAuth(username, password)` to configure GoFr with pre-defined credentials.

```go
func main() {
	app := gofr.New()
    
	app.EnableBasicAuth("admin", "secret_password") // Replace with your credentials
    
	app.GET("/protected-resource", func(c *gofr.Context) (interface{}, error) {
		// Handle protected resource access 
		return nil, nil
	})

	app.Run()
}
```

**2. Custom Validation Function**

Use `EnableBasicAuthWithValidator(validationFunc)` to implement your own validation logic for credentials.
The `validationFunc` takes the username and password as arguments and returns true if valid, false otherwise.

```go
func validateUser(c *container.Container, username, password string) bool {
	// Implement your credential validation logic here 
	// This example uses hardcoded credentials for illustration only   
	return username == "john" && password == "doe123" 
} 

func main() { 
	app := gofr.New() 

	app.EnableBasicAuthWithValidator(validateUser) 

	app.GET("/secure-data", func(c *gofr.Context) (interface{}, error) { 
		// Handle access to secure data 
		return nil, nil
	})

	app.Run()
}
```

### Adding Basic Authentication to HTTP Services
This code snippet demonstrates how to add basic authentication to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("order", "https://localhost:2000",
    &service.Authentication{UserName: "abc", Password: "pass"},
)
```

## 2. API Keys Auth
*API Key Authentication* is an HTTP authentication scheme where a unique API key is included in the request header for validation against a store of authorized keys.

### Usage:
GoFr offers two ways to implement API Keys authentication.

**1. Framework Default Validation**
- GoFr's default validation can be selected using **_EnableAPIKeyAuth(apiKeys ...string)_**

```go
package main

func main() {
	// initialise gofr object
	app := gofr.New()

	app.EnableAPIKeyAuth("9221e451-451f-4cd6-a23d-2b2d3adea9cf", "0d98ecfe-4677-48aa-b463-d43505766915")

	app.GET("/customer", Customer)

	app.Run()
}
```

**2. Custom Validation Function**
- GoFr allows a custom validator function `apiKeyValidator(apiKey string) bool` for validating APIKeys and pass the func in **_EnableAPIKeyAuthWithValidator(validator)_**

```go
package main

func apiKeyValidator(c *container.Container, apiKey string) bool {
	validKeys := []string{"f0e1dffd-0ff0-4ac8-92a3-22d44a1464e4", "d7e4b46e-5b04-47b2-836c-2c7c91250f40"}

	return slices.Contains(validKeys, apiKey)
}

func main() {
	// initialise gofr object
	app := gofr.New()

	app.EnableAPIKeyAuthWithValidator(apiKeyValidator)

	app.GET("/customer", Customer)

	app.Run()
}
```

### Adding API-KEY Authentication to HTTP Services
This code snippet demonstrates how to add API Key authentication to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("http-server-using-redis", "http://localhost:8000", &service.APIKeyConfig{APIKey: "9221e451-451f-4cd6-a23d-2b2d3adea9cf"})
```

## 3. OAuth 2.0
{% new-tab-link title="OAuth" href="https://www.rfc-editor.org/rfc/rfc6749" /%} 2.0 is the industry-standard protocol for authorization. 
It focuses on client developer simplicity while providing specific authorization flows for web applications, desktop applications, mobile phones, and living room devices.

It involves sending the prefix `Bearer` trailed by the encoded token within the standard `Authorization` header.

### OAuth Authentication in GoFr

GoFr supports authenticating tokens encoded by algorithm `RS256/384/512`. 

### App level Authentication
Enable OAuth 2.0 with three-legged flow to authenticate requests

Use `EnableOAuth(jwks-endpoint,refresh_interval)` to configure GoFr with pre-defined credentials.

```go
func main() {
	app := gofr.New()

	app.EnableOAuth("http://jwks-endpoint", 20) 
    
	app.GET("/protected-resource", func(c *gofr.Context) (interface{}, error) {
		// Handle protected resource access 
		return nil, nil
	})

	app.Run()
}
```

### Adding OAuth Authentication to HTTP Services
For server-to-server communication it follows two-legged OAuth, also known as "client credentials" flow,
where the client application directly exchanges its own credentials (ClientID and ClientSecret)
for an access token without involving any end-user interaction.

This code snippet demonstrates how two-legged OAuth authentication is added to an HTTP service in GoFr and make a request with the appropriate Authorization header:

```go
app.AddHTTPService("orders", "http://localhost:9000",
    &service.OAuthConfig{   // Replace with your credentials
        ClientID:     "0iyeGcLYWudLGqZfD6HvOdZHZ5TlciAJ",
        ClientSecret: "GQXTY2f9186nUS3C9WWi7eJz8-iVEsxq7lKxdjfhOJbsEPPtEszL3AxFn8k_NAER",
        TokenURL:     "https://dev-zq6tvaxf3v7p0g7j.us.auth0.com/oauth/token",
        Scopes:       []string{"read:order"},
        EndpointParams: map[string][]string{
            "audience": {"https://dev-zq6tvaxf3v7p0g7j.us.auth0.com/api/v2/"},
    },
})
```
# Injecting Database Drivers
Keeping in mind the size of the framework in the final build, it felt counter-productive to keep all the database drivers within
the framework itself. Keeping only the most used MySQL and Redis within the framework, users can now inject databases
in the server that satisfies the base interface defined by GoFr. This helps in reducing the build size and in turn build time
as unnecessary database drivers are not being compiled and added to the build.

> We are planning to provide custom drivers for most common databases, and is in the pipeline for upcoming releases!


## Clickhouse
GoFr supports injecting Clickhouse that supports the following interface. Any driver that implements the interface can be added
using `app.AddClickhouse()` method, and user's can use Clickhouse across application with `gofr.Context`.
```go
type Clickhouse interface {
    Exec(ctx context.Context, query string, args ...any) error
    Select(ctx context.Context, dest any, query string, args ...any) error
    AsyncInsert(ctx context.Context, query string, wait bool, args ...any) error
}
```

User's can easily inject a driver that supports this interface, this provides usability without
compromising the extensibility to use multiple databases.

Import the gofr's external driver for ClickHouse:

```shell
go get gofr.dev/pkg/gofr/datasource/clickhouse@latest
```

### Example
```go
package main

import (
    "gofr.dev/pkg/gofr"

    "gofr.dev/pkg/gofr/datasource/clickhouse"
)

type User struct {
    Id   string `ch:"id"`
    Name string `ch:"name"`
    Age  string `ch:"age"`
}

func main() {
    app := gofr.New()

    app.AddClickhouse(clickhouse.New(clickhouse.Config{
        Hosts:    "localhost:9001",
        Username: "root",
        Password: "password",
        Database: "users",
    }))
    
    app.POST("/user", Post)
    app.GET("/user", Get)
    
    app.Run()
}

func Post(ctx *gofr.Context) (interface{}, error) {
    err := ctx.Clickhouse.Exec(ctx, "INSERT INTO users (id, name, age) VALUES (?, ?, ?)", "8f165e2d-feef-416c-95f6-913ce3172e15", "aryan", "10")
    if err != nil {
        return nil, err
    }

    return "successful inserted", nil
}

func Get(ctx *gofr.Context) (interface{}, error) {
    var user []User

    err := ctx.Clickhouse.Select(ctx, &user, "SELECT * FROM users")
    if err != nil {
        return nil, err
    }

    return user, nil
}
```

## MongoDB
GoFr supports injecting MongoDB that supports the following interface. Any driver that implements the interface can be added
using `app.AddMongo()` method, and user's can use MongoDB across application with `gofr.Context`.
```go
type Mongo interface {
	Find(ctx context.Context, collection string, filter interface{}, results interface{}) error
	
	FindOne(ctx context.Context, collection string, filter interface{}, result interface{}) error
	
	InsertOne(ctx context.Context, collection string, document interface{}) (interface{}, error)
	
	InsertMany(ctx context.Context, collection string, documents []interface{}) ([]interface{}, error)
	
	DeleteOne(ctx context.Context, collection string, filter interface{}) (int64, error)
	
	DeleteMany(ctx context.Context, collection string, filter interface{}) (int64, error)
	
	UpdateByID(ctx context.Context, collection string, id interface{}, update interface{}) (int64, error)
	
	UpdateOne(ctx context.Context, collection string, filter interface{}, update interface{}) error
	
	UpdateMany(ctx context.Context, collection string, filter interface{}, update interface{}) (int64, error)
	
	CountDocuments(ctx context.Context, collection string, filter interface{}) (int64, error)
	
	Drop(ctx context.Context, collection string) error
}
```

User's can easily inject a driver that supports this interface, this provides usability without
compromising the extensibility to use multiple databases.

Import the gofr's external driver for MongoDB:

```shell
go get gofr.dev/pkg/gofr/datasource/mongo@latest
```

### Example
```go
package main

import (
    "gofr.dev/pkg/gofr/datasource/mongo"
    "go.mongodb.org/mongo-driver/bson"
	
    "gofr.dev/pkg/gofr"
)

type Person struct {
	Name string `bson:"name" json:"name"`
	Age  int    `bson:"age" json:"age"`
	City string `bson:"city" json:"city"`
}

func main() {
	app := gofr.New()
	
	db := mongo.New(Config{URI: "mongodb://localhost:27017", Database: "test"})
	
	// inject the mongo into gofr to use mongoDB across the application
	// using gofr context
	app.AddMongo(db)

	app.POST("/mongo", Insert)
	app.GET("/mongo", Get)

	app.Run()
}

func Insert(ctx *gofr.Context) (interface{}, error) {
	var p Person
	err := ctx.Bind(&p)
	if err != nil {
		return nil, err
	}

	res, err := ctx.Mongo.InsertOne(ctx, "collection", p)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func Get(ctx *gofr.Context) (interface{}, error) {
	var result Person

	p := ctx.Param("name")

	err := ctx.Mongo.FindOne(ctx, "collection", bson.D{{"name", p}} /* valid filter */, &result)
	if err != nil {
		return nil, err
	}

	return result, nil
}
```

## Cassandra
GoFr supports pluggable Cassandra drivers. It defines an interface that specifies the required methods for interacting 
with Cassandra. Any driver implementation that adheres to this interface can be integrated into GoFr using the 
`app.AddCassandra()` method. This approach promotes flexibility and allows you to choose the Cassandra driver that best 
suits your project's needs.

```go
type CassandraWithContext interface {
	QueryWithCtx(ctx context.Context, dest any, stmt string, values ...any) error

	ExecWithCtx(ctx context.Context, stmt string, values ...any) error

	ExecCASWithCtx(ctx context.Context, dest any, stmt string, values ...any) (bool, error)

	NewBatchWithCtx(ctx context.Context, name string, batchType int) error

	Cassandra
	CassandraBatchWithContext
}

type CassandraBatchWithContext interface {
	BatchQueryWithCtx(ctx context.Context, name, stmt string, values ...any) error

	ExecuteBatchWithCtx(ctx context.Context, name string) error

	ExecuteBatchCASWithCtx(ctx context.Context, name string, dest ...any) (bool, error)
}
```

GoFr simplifies Cassandra integration with a well-defined interface. Users can easily implement any driver that adheres 
to this interface, fostering a user-friendly experience.

Import the gofr's external driver for Cassandra:

```shell
go get gofr.dev/pkg/gofr/datasource/cassandra@latest
```

### Example

```go
package main

import (
	"gofr.dev/pkg/gofr"
	cassandraPkg "gofr.dev/pkg/gofr/datasource/cassandra"
)

type Person struct {
	ID    int    `json:"id,omitempty"`
	Name  string `json:"name"`
	Age   int    `json:"age"`
        // db tag specifies the actual column name in the database
	State string `json:"state" db:"location"` 
}

func main() {
	app := gofr.New()

	config := cassandraPkg.Config{
		Hosts:    "localhost",
		Keyspace: "test",
		Port:     2003,
		Username: "cassandra",
		Password: "cassandra",
	}

	cassandra := cassandraPkg.New(config)

	app.AddCassandra(cassandra)

	app.POST("/user", func(c *gofr.Context) (interface{}, error) {
		person := Person{}

		err := c.Bind(&person)
		if err != nil {
			return nil, err
		}

		err = c.Cassandra.ExecWithCtx(c,`INSERT INTO persons(id, name, age, location) VALUES(?, ?, ?, ?)`,
			person.ID, person.Name, person.Age, person.State)
		if err != nil {
			return nil, err
		}

		return "created", nil
	})

	app.GET("/user", func(c *gofr.Context) (interface{}, error) {
		persons := make([]Person, 0)

		err := c.Cassandra.QueryWithCtx(c, &persons, `SELECT id, name, age, location FROM persons`)

		return persons, err
	})

	app.Run()
}
```
## DGraph
GoFr supports injecting Dgraph with an interface that defines the necessary methods for interacting with the Dgraph 
database. Any driver that implements the following interface can be added using the app.AddDgraph() method.

```go
// Dgraph defines the methods for interacting with a Dgraph database.
type Dgraph interface {
	// Query executes a read-only query in the Dgraph database and returns the result.
	Query(ctx context.Context, query string) (interface{}, error)

	// QueryWithVars executes a read-only query with variables in the Dgraph database.
	QueryWithVars(ctx context.Context, query string, vars map[string]string) (interface{}, error)

	// Mutate executes a write operation (mutation) in the Dgraph database and returns the result.
	Mutate(ctx context.Context, mu interface{}) (interface{}, error)

	// Alter applies schema or other changes to the Dgraph database.
	Alter(ctx context.Context, op interface{}) error

	// NewTxn creates a new transaction (read-write) for interacting with the Dgraph database.
	NewTxn() interface{}

	// NewReadOnlyTxn creates a new read-only transaction for querying the Dgraph database.
	NewReadOnlyTxn() interface{}

	// HealthChecker checks the health of the Dgraph instance.
	HealthChecker
}
```

Users can easily inject a driver that supports this interface, allowing for flexibility without compromising usability.
This structure supports both queries and mutations in Dgraph.

Import the gofr's external driver for DGraph:

```shell
go get gofr.dev/pkg/gofr/datasource/dgraph@latest
```

### Example

```go
package main

import (
	"encoding/json"
	"fmt"

	"github.com/dgraph-io/dgo/v210/protos/api"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/datasource/dgraph"
)

func main() {
	// Create a new application
	app := gofr.New()

	db := dgraph.New(dgraph.Config{
		Host: "localhost",
		Port: "8080",
	})

	// Connect to Dgraph running on localhost:9080
	app.AddDgraph(db)

	// Add routes for Dgraph operations
	app.POST("/dgraph", DGraphInsertHandler)
	app.GET("/dgraph", DGraphQueryHandler)

	// Run the application
	app.Run()
}

// DGraphInsertHandler handles POST requests to insert data into Dgraph
func DGraphInsertHandler(c *gofr.Context) (interface{}, error) {
	// Example mutation data to insert into Dgraph
	mutationData := `
		{
			"set": [
				{
					"name": "GoFr Dev"
				},
				{
					"name": "James Doe"
				}
			]
		}
	`

	// Create an api.Mutation object
	mutation := &api.Mutation{
		SetJson:   []byte(mutationData), // Set the JSON payload
		CommitNow: true,                 // Auto-commit the transaction
	}

	// Run the mutation in Dgraph
	response, err := c.DGraph.Mutate(c, mutation)
	if err != nil {
		return nil, err
	}

	return response, nil
}

// DGraphQueryHandler handles GET requests to fetch data from Dgraph
func DGraphQueryHandler(c *gofr.Context) (interface{}, error) {
	// A simple query to fetch all persons with a name in Dgraph
	response, err := c.DGraph.Query(c, "{ persons(func: has(name)) { uid name } }")
	if err != nil {
		return nil, err
	}

	// Cast response to *api.Response (the correct type returned by Dgraph Query)
	resp, ok := response.(*api.Response)
	if !ok {
		return nil, fmt.Errorf("unexpected response type")
	}

	// Parse the response JSON
	var result map[string]interface{}
	err = json.Unmarshal(resp.Json, &result)
	if err != nil {
		return nil, err
	}

	return result, nil
}

```




## Solr
GoFr supports injecting Solr database that supports the following interface. Any driver that implements the interface can be added
using `app.AddSolr()` method, and user's can use Solr DB across application with `gofr.Context`.

```go
type Solr interface {
    Search(ctx context.Context, collection string, params map[string]any) (any, error)
    Create(ctx context.Context, collection string, document *bytes.Buffer, params map[string]any) (any, error)
    Update(ctx context.Context, collection string, document *bytes.Buffer, params map[string]any) (any, error)
    Delete(ctx context.Context, collection string, document *bytes.Buffer, params map[string]any) (any, error)
    
    Retrieve(ctx context.Context, collection string, params map[string]any) (any, error)
    ListFields(ctx context.Context, collection string, params map[string]any) (any, error)
    AddField(ctx context.Context, collection string, document *bytes.Buffer) (any, error)
    UpdateField(ctx context.Context, collection string, document *bytes.Buffer) (any, error)
    DeleteField(ctx context.Context, collection string, document *bytes.Buffer) (any, error)
}
```

User's can easily inject a driver that supports this interface, this provides usability
without compromising the extensibility to use multiple databases.

Import the gofr's external driver for Solr:

```shell
go get gofr.dev/pkg/gofr/datasource/solr@latest
```

```go
package main

import (
	"bytes"
	"encoding/json"
	"errors"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/datasource/solr"
)

func main() {
	app := gofr.New()

	app.AddSolr(solr.New(solr.Config{
		Host: "localhost",
		Port: "2020",
	}))

	app.POST("/solr", post)
	app.GET("/solr", get)

	app.Run()
}

type Person struct {
	Name string
	Age  int
}

func post(c *gofr.Context) (interface{}, error) {
	p := Person{Name: "Srijan", Age: 24}
	body, _ := json.Marshal(p)

	resp, err := c.Solr.Create(c, "test", bytes.NewBuffer(body), nil)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

func get(c *gofr.Context) (interface{}, error) {
	resp, err := c.Solr.Search(c, "test", nil)
	if err != nil {
		return nil, err
	}

	res, ok := resp.(solr.Response)
	if !ok {
		return nil, errors.New("invalid response type")
	}

	b, _ := json.Marshal(res.Data)
	err = json.Unmarshal(b, &Person{})
	if err != nil {
		return nil, err
	}

	return resp, nil
}
```

## OpenTSDB
GoFr supports injecting OpenTSDB to facilitate interaction with OpenTSDB's REST APIs. 
Implementations adhering to the `OpenTSDB` interface can be registered with `app.AddOpenTSDB()`, 
enabling applications to leverage OpenTSDB for time-series data management through `gofr.Context`.

```go
// OpenTSDB provides methods for GoFr applications to communicate with OpenTSDB
// through its REST APIs. 
type OpenTSDB interface {

// HealthChecker verifies if the OpenTSDB server is reachable.
// Returns an error if the server is unreachable, otherwise nil.
HealthChecker

// PutDataPoints sends data to store metrics in OpenTSDB.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - data: A slice of DataPoint objects; must contain at least one entry.
// - queryParam: Specifies the response format:
//   - client.PutRespWithSummary: Requests a summary response.
//   - client.PutRespWithDetails: Requests detailed response information.
//   - Empty string (""): No additional response details.
// - res: A pointer to PutResponse, where the server's response will be stored.
//
// Returns:
// - Error if parameters are invalid, response parsing fails, or if connectivity issues occur.
PutDataPoints(ctx context.Context, data any, queryParam string, res any) error

// QueryDataPoints retrieves data based on the specified parameters.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - param: An instance of QueryParam with query parameters for filtering data.
// - res: A pointer to QueryResponse, where the server's response will be stored.
QueryDataPoints(ctx context.Context, param any, res any) error

// QueryLatestDataPoints fetches the latest data point(s).
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - param: An instance of QueryLastParam with query parameters for the latest data point.
// - res: A pointer to QueryLastResponse, where the server's response will be stored.
QueryLatestDataPoints(ctx context.Context, param any, res any) error

// GetAggregators retrieves available aggregation functions.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - res: A pointer to AggregatorsResponse, where the server's response will be stored.
GetAggregators(ctx context.Context, res any) error

// QueryAnnotation retrieves a single annotation.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - queryAnnoParam: A map of parameters for the annotation query, such as client.AnQueryStartTime, client.AnQueryTSUid.
// - res: A pointer to AnnotationResponse, where the server's response will be stored.
QueryAnnotation(ctx context.Context, queryAnnoParam map[string]any, res any) error

// PostAnnotation creates or updates an annotation.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - annotation: The annotation to be created or updated.
// - res: A pointer to AnnotationResponse, where the server's response will be stored.
PostAnnotation(ctx context.Context, annotation any, res any) error

// PutAnnotation creates or replaces an annotation.
// Fields not included in the request will be reset to default values.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - annotation: The annotation to be created or replaced.
// - res: A pointer to AnnotationResponse, where the server's response will be stored.
PutAnnotation(ctx context.Context, annotation any, res any) error

// DeleteAnnotation removes an annotation.
//
// Parameters:
// - ctx: Context for managing request lifetime.
// - annotation: The annotation to be deleted.
// - res: A pointer to AnnotationResponse, where the server's response will be stored.
DeleteAnnotation(ctx context.Context, annotation any, res any) error
}
```

Import the gofr's external driver for OpenTSDB:

```go
go get gofr.dev/pkg/gofr/datasource/opentsdb
```

The following example demonstrates injecting an OpenTSDB instance into a GoFr application 
and using it to perform a health check on the OpenTSDB server.
```go
package main

import (
	"context"
	"fmt"
	"math/rand/v2"
	"time"

	"gofr.dev/pkg/gofr"
	"gofr.dev/pkg/gofr/datasource/opentsdb"
)

func main() {
	app := gofr.New()

	// Initialize OpenTSDB connection
	app.AddOpenTSDB(opentsdb.New(&opentsdb.Config{
		Host:             "localhost:4242",
		MaxContentLength: 4096,
		MaxPutPointsNum:  1000,
		DetectDeltaNum:   10,
	}))

	// Register routes
	app.GET("/health", opentsdbHealthCheck)
	app.POST("/write", writeDataPoints)
	app.GET("/query", queryDataPoints)
	// Run the app
	app.Run()
}

// Health check for OpenTSDB
func opentsdbHealthCheck(c *gofr.Context) (any, error) {
	res, err := c.OpenTSDB.HealthCheck(context.Background())
	if err != nil {
		return nil, err
	}
	return res, nil
}

// Write Data Points to OpenTSDB
func writeDataPoints(c *gofr.Context) (any, error) {
	PutDataPointNum := 4
	name := []string{"cpu", "disk", "net", "mem"}
	cpuDatas := make([]opentsdb.DataPoint, 0)

	tags := map[string]string{
		"host":      "gofr-host",
		"try-name":  "gofr-sample",
		"demo-name": "opentsdb-test",
	}

	for i := 0; i < PutDataPointNum; i++ {
		data := opentsdb.DataPoint{
			Metric:    name[i%len(name)],
			Timestamp: time.Now().Unix(),
			Value:     rand.Float64() * 100,
			Tags:      tags,
		}
		cpuDatas = append(cpuDatas, data)
	}

	resp := opentsdb.PutResponse{}

	err := c.OpenTSDB.PutDataPoints(context.Background(), cpuDatas, "details", &resp)
	if err != nil {
		return resp.Errors, err
	}

	return fmt.Sprintf("%v Data points written successfully", resp.Success), nil
}

// Query Data Points from OpenTSDB
func queryDataPoints(c *gofr.Context) (any, error) {
	st1 := time.Now().Unix() - 3600
	st2 := time.Now().Unix()

	queryParam := opentsdb.QueryParam{
		Start: st1,
		End:   st2,
	}

	name := []string{"cpu", "disk", "net", "mem"}
	subqueries := make([]opentsdb.SubQuery, 0)
	tags := map[string]string{
		"host":      "gofr-host",
		"try-name":  "gofr-sample",
		"demo-name": "opentsdb-test",
	}

	for _, metric := range name {
		subQuery := opentsdb.SubQuery{
			Aggregator: "sum",
			Metric:     metric,
			Tags:       tags,
		}
		subqueries = append(subqueries, subQuery)
	}

	queryParam.Queries = subqueries

	queryResp := &opentsdb.QueryResponse{}

	err := c.OpenTSDB.QueryDataPoints(c, &queryParam, queryResp)
	if err != nil {
		return nil, err
	}
	return queryResp.QueryRespCnts, nil
}
```# Monitoring Service Health

Health check in microservices refers to a mechanism or process implemented within each service to assess its operational status
and readiness to handle requests. It involves regularly querying the service to determine if it is functioning correctly,
typically by evaluating its responsiveness and ability to perform essential tasks. Health checks play a critical role in ensuring service availability,
detecting failures, preventing cascading issues, and facilitating effective traffic routing in distributed systems.

## GoFr by default registers two endpoints which are:

### 1. Aliveness - /.well-known/alive

It is an endpoint which returns the following response with a 200 status code, when the service is UP.

```json
{
  "data": {
    "status": "UP"
  }
}
```

It is also used when state of {% new-tab-link newtab=false title="circuit breaker" href="/docs/advanced-guide/circuit-breaker" /%} is open.

To override this endpoint, pass the following option while registering HTTP Service:
```go
&service.HealthConfig{
			HealthEndpoint: "breeds",
		}
```

### 2. Health-Check - /.well-known/health

It is an endpoint which returns whether the service is UP or DOWN along with stats, host, status about the dependent datasources and services.

Sample response of how it appears when all the services, and connected data sources are UP:
```json
{
  "data": {
    "anotherService": {
      "status": "UP",
      "details": {
        "host": "localhost:9000"
      }
    },
    "redis": {
      "status": "UP",
      "details": {
        "host": "localhost:2002",
        "stats": {
          "active_defrag_hits": "0",
          "active_defrag_key_hits": "0",
          "active_defrag_key_misses": "0",
          "active_defrag_misses": "0",
          "current_active_defrag_time": "0",
          "current_eviction_exceeded_time": "0",
          "dump_payload_sanitizations": "0",
          "evicted_clients": "0",
          "evicted_keys": "0",
          "expire_cycle_cpu_milliseconds": "1",
          "expired_keys": "0",
          "expired_stale_perc": "0.00",
          "expired_time_cap_reached_count": "0",
          "instantaneous_input_kbps": "0.00",
          "instantaneous_input_repl_kbps": "0.00",
          "instantaneous_ops_per_sec": "0",
          "instantaneous_output_kbps": "0.00",
          "instantaneous_output_repl_kbps": "0.00",
          "io_threaded_reads_processed": "0",
          "io_threaded_writes_processed": "0",
          "keyspace_hits": "0",
          "keyspace_misses": "0",
          "latest_fork_usec": "0",
          "migrate_cached_sockets": "0",
          "pubsub_channels": "0",
          "pubsub_patterns": "0",
          "pubsubshard_channels": "0",
          "rejected_connections": "0",
          "reply_buffer_expands": "0",
          "reply_buffer_shrinks": "1",
          "slave_expires_tracked_keys": "0",
          "sync_full": "0",
          "sync_partial_err": "0",
          "sync_partial_ok": "0",
          "total_active_defrag_time": "0",
          "total_commands_processed": "2",
          "total_connections_received": "1",
          "total_error_replies": "2",
          "total_eviction_exceeded_time": "0",
          "total_forks": "0",
          "total_net_input_bytes": "183",
          "total_net_output_bytes": "257",
          "total_net_repl_input_bytes": "0",
          "total_net_repl_output_bytes": "0",
          "total_reads_processed": "5",
          "total_writes_processed": "4",
          "tracking_total_items": "0",
          "tracking_total_keys": "0",
          "tracking_total_prefixes": "0",
          "unexpected_error_replies": "0"
        }
      }
    },
    "sql": {
      "status": "UP",
      "details": {
        "host": "localhost:2001/test",
        "stats": {
          "maxOpenConnections": 0,
          "openConnections": 1,
          "inUse": 0,
          "idle": 1,
          "waitCount": 0,
          "waitDuration": 0,
          "maxIdleClosed": 0,
          "maxIdleTimeClosed": 0,
          "maxLifetimeClosed": 0
        }
      }
    }
  }
}
```
# Overriding Default

GoFr allows overriding default behavior of its features.

## Raw response format

GoFr by default wraps a handler's return value and assigns it to the `data` field in a response.

### Example

```go
package main

import "gofr.dev/pkg/gofr"

type user struct {
  ID   int    `json:"id"`
  Name string `json:"name"`
}

func main() {
  app := gofr.New()

  app.GET("/users", func(ctx *gofr.Context) (interface{}, error) {

    users := []user{{ID: 1, Name: "Daria"}, {ID: 2, Name: "Ihor"}}

    return users, nil
  })

  app.Run()
}
```

Response example:
```json
{
  "data": [
    {
      "id": 1,
      "name": "Daria"
    },
    {
      "id": 2,
      "name": "Ihor"
    }
  ]
}
```

If you want to have a raw response structure - wrap it in `response.Raw`:
```go
app.GET("/users", func(ctx *gofr.Context) (interface{}, error) {

    users := []user{{ID: 1, Name: "Daria"}, {ID: 2, Name: "Ihor"}}

    return response.Raw{Data: users}, nil	
})
```

Response example:
```json
[
  {
    "id": 1,
    "name": "Daria"
  },
  {
    "id": 2,
    "name": "Ihor"
  }
]
```

## Favicon.ico

By default, GoFr load its own `favicon.ico` present in root directory for an application. To override `favicon.ico` user
can place its custom icon in the **static** directory of its application.

> NOTE: The custom favicon should also be named as `favicon.ico` in the static directory of application.
# Remote Log Level Change

GoFr makes it easy to adjust the details captured in the application's logs, even while it's running!

This feature allows users to effortlessly fine-tune logging levels without the need for redeployment, enhancing the monitoring and debugging experience.
It is facilitated through simple configuration settings.

## How it helps?

- **Effortless Adjustments:** Modify the log level anytime without restarting the application. This is especially helpful during troubleshooting.
- **Enhanced Visibility:** Easily switch to a more detailed log level (e.g., `DEBUG`) to gain deeper insights into specific issues,
  and then switch back to a less detailed level (e.g., `INFO`) for regular operation.
- **Improved Performance:** Generating a large number of logs can overwhelm the logging system, leading to increased I/O operations and resource consumption,
  changing to Warn or Error Level reduces the number of logs, and enhancing performance.

## Configuration

To enable remote log level update, users need to specify the following configuration parameter:

```dotenv
REMOTE_LOG_URL=<URL to user's remote log level endpoint> (e.g., https://log-service.com/log-levels)
REMOTE_LOG_FETCH_INTERVAL=<Interval in seconds> (default: 15)
```

- **REMOTE_LOG_URL:** Specifies the URL of the remote log level endpoint.
- **REMOTE_LOG_FETCH_INTERVAL:** Defines the time interval (in seconds) at which GoFr fetches log level configurations from the endpoint.

> NOTE: If not provided the default interval between the request to fetch log level is **15 seconds**.

## Remote Log Level Endpoint

The remote log level endpoint should return a JSON response in the following format:

```json
{
  "data": {
    "serviceName": "test-service",
    "logLevel": "DEBUG"
  }
}
```

- **serviceName:** Identifies the service for which log levels are configured.
- **logLevel:** The new log level user want to set for the specified service.

GoFr parses this response and adjusts log levels based on the provided configurations.
# Rendering OpenAPI Documentation in GoFr

GoFr supports automatic rendering of OpenAPI (also known as Swagger) documentation. This feature allows you to
easily provide interactive API documentation for your users.

## What is OpenAPI/Swagger Documentation?

OpenAPI, also known as Swagger, is a specification for building APIs. An OpenAPI file allows you to describe your entire API, including:

- Available endpoints (/users) and operations on each endpoint (GET /users, DELETE /users/{id})
- Operation parameters, input, and output for each operation
- Authentication methods
- Contact information, license, terms of use, and other information.

API specifications can be written in YAML or JSON. The format is easy to learn and readable to both humans and machines. 
The complete OpenAPI Specification can be found on the official [Swagger website](https://swagger.io/).

## Enabling GoFr to render your openapi.json file

To allow GoFr to render your OpenAPI documentation, simply place your `openapi.json` file inside the `static` directory of your project.
GoFr will automatically render the Swagger documentation at the `/.well-known/swagger` endpoint.

Here are the steps:

- Create an `openapi.json` file that describes your API according to the OpenAPI specification.
- Place the `openapi.json` file inside the `static` directory in your project.
- Start your GoFr server.
- Navigate to `/.well-known/swagger` on your serverâ€™s URL.

You should now see a beautifully rendered, interactive documentation for your API that users can use to understand and interact with your API.
# Publisher Subscriber

Publisher Subscriber is an architectural design pattern for asynchronous communication between different entities.
These could be different applications or different instances of the same application.
Thus, the movement of messages between the components is made possible without the components being aware of each other's
identities, meaning the components are decoupled.
This makes the application/system more flexible and scalable as each component can be 
scaled and maintained according to its own requirement.

## Design choice

In GoFr application if a user wants to use the Publisher-Subscriber design, it supports several message brokers, 
including Apache Kafka, Google PubSub, MQTT, and NATS JetStream.
The initialization of the PubSub is done in an IoC container which handles the PubSub client dependency.
With this, the control lies with the framework and thus promotes modularity, testability, and re-usability.
Users can do publish and subscribe to multiple topics in a single application, by providing the topic name.
Users can access the methods of the container to get the Publisher and Subscriber interface to perform subscription 
to get a single message or publish a message on the message broker.
> Container is part of the GoFr Context

## Configuration and Setup

Some of the configurations that are required to configure the PubSub backend that an application is to use
that are specific for the type of message broker user wants to use. 
`PUBSUB_BACKEND` defines which message broker the application needs to use.

### KAFKA

#### Configs
{% table %}
- Name
- Description
- Required
- Default
- Example
- Valid format

---

- `PUBSUB_BACKEND`
- Using Apache Kafka as message broker.
- `+`
-
- `KAFKA`
- Not empty string

---

- `PUBSUB_BROKER`
- Address to connect to kafka broker.
- `+`
-
- `localhost:9092`
- Not empty string

---

- `CONSUMER_ID`
- Consumer group id to uniquely identify the consumer group.
- if consuming
-
- `order-consumer`
- Not empty string

---

- `PUBSUB_OFFSET`
- Determines from whence the consumer group should begin consuming when it finds a partition without a committed offset.
- `-`
- `-1`
- `10`
- int

---

- `KAFKA_BATCH_SIZE`
- Limit on how many messages will be buffered before being sent to a partition.
- `-`
- `100`
- `10`
- Positive int

---

- `KAFKA_BATCH_BYTES`
- Limit the maximum size of a request in bytes before being sent to a partition.
- `-`
- `1048576`
- `65536`
- Positive int

---

- `KAFKA_BATCH_TIMEOUT`
- Time limit on how often incomplete message batches will be flushed to Kafka (in milliseconds).
- `-`
- `1000`
- `300`
- Positive int 

{% /table %}

```dotenv
PUBSUB_BACKEND=KAFKA# using apache kafka as message broker
PUBSUB_BROKER=localhost:9092
CONSUMER_ID=order-consumer
KAFKA_BATCH_SIZE=1000
KAFKA_BATCH_BYTES=1048576
KAFKA_BATCH_TIMEOUT=300
```

#### Docker setup
```shell
docker run --name kafka-1 -p 9092:9092 \
 -e KAFKA_ENABLE_KRAFT=yes \
-e KAFKA_CFG_PROCESS_ROLES=broker,controller \
-e KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER \
-e KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 \
-e KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT \
-e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 \
-e KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true \
-e KAFKA_BROKER_ID=1 \
-e KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@127.0.0.1:9093 \
-e ALLOW_PLAINTEXT_LISTENER=yes \
-e KAFKA_CFG_NODE_ID=1 \
-v kafka_data:/bitnami \
bitnami/kafka:3.4 
```

### GOOGLE

#### Configs
```dotenv
PUBSUB_BACKEND=GOOGLE                   // using Google PubSub as message broker
GOOGLE_PROJECT_ID=project-order         // google projectId where the PubSub is configured
GOOGLE_SUBSCRIPTION_NAME=order-consumer // unique subscription name to identify the subscribing entity
```

#### Docker setup
```shell
docker pull gcr.io/google.com/cloudsdktool/google-cloud-cli:emulators
docker run --name=gcloud-emulator -d -p 8086:8086 \
       gcr.io/google.com/cloudsdktool/google-cloud-cli:emulators gcloud beta emulators pubsub start --project=test123 \
       --host-port=0.0.0.0:8086
```
> **Note**: To set GOOGLE_APPLICATION_CREDENTIAL - refer {% new-tab-link title="here" href="https://cloud.google.com/docs/authentication/application-default-credentials" /%}

> **Note**: In Google PubSub only one subscription name can access one topic, framework appends the topic name and subscription name to form the
> unique subscription name on the Google client.

### MQTT

#### Configs
```dotenv
PUBSUB_BACKEND=MQTT            // using Mqtt as pubsub
MQTT_HOST=localhost            // broker host url
MQTT_PORT=1883                 // broker port
MQTT_CLIENT_ID_SUFFIX=test     // suffix to a random generated client-id(uuid v4)

#some additional configs(optional)
MQTT_PROTOCOL=tcp              // protocol for connecting to broker can be tcp, tls, ws or wss
MQTT_MESSAGE_ORDER=true  // config to maintain/retain message publish order, by default this is false
MQTT_USER=username       // authentication username
MQTT_PASSWORD=password   // authentication password 
```
> **Note** : If `MQTT_HOST` config is not provided, the application will connect to a public broker
> {% new-tab-link title="HiveMQ" href="https://www.hivemq.com/mqtt/public-mqtt-broker/" /%}

#### Docker setup
```shell 
docker run -d \
  --name mqtt \
  -p 8883:8883 \
  -v <path-to>/mosquitto.conf:/mosquitto/config/mosquitto.conf \
  eclipse-mosquitto:latest
```
> **Note**: find the default mosquitto config file {% new-tab-link title="here" href="https://github.com/eclipse/mosquitto/blob/master/mosquitto.conf" /%}
 
### NATS JetStream

NATS JetStream is supported as an external pubsub provider, meaning if you're not using it, it won't be added to your binary.

**References**

https://docs.nats.io/
https://docs.nats.io/nats-concepts/jetstream
https://docs.nats.io/using-nats/developer/connecting/creds

#### Configs
```dotenv
PUBSUB_BACKEND=NATS
PUBSUB_BROKER=nats://localhost:4222
NATS_STREAM=mystream
NATS_SUBJECTS=orders.*,shipments.*
NATS_MAX_WAIT=5s
NATS_MAX_PULL_WAIT=500ms
NATS_CONSUMER=my-consumer
NATS_CREDS_FILE=/path/to/creds.json
```

#### Setup

To set up NATS JetStream, follow these steps:

1. Import the external driver for NATS JetStream:

```bash
go get gofr.dev/pkg/gofr/datasources/pubsub/nats
```

2. Use the `AddPubSub` method to add the NATS JetStream driver to your application:

```go   
app := gofr.New()

app.AddPubSub(nats.New(nats.Config{
    Server:     "nats://localhost:4222",
    Stream: nats.StreamConfig{
        Stream:   "mystream",
        Subjects: []string{"orders.*", "shipments.*"},
    },
    MaxWait:     5 * time.Second,
    MaxPullWait: 500 * time.Millisecond,
    Consumer:    "my-consumer",
    CredsFile:   "/path/to/creds.json",
}))
```

#### Docker setup
```shell
docker run -d \
  --name nats \
  -p 4222:4222 \
  -p 8222:8222 \
  -v <path-to>/nats.conf:/nats/config/nats.conf \
  nats:2.9.16
``` 

#### Configuration Options

| Name | Description | Required | Default | Example |
|------|-------------|----------|---------|---------|
| `PUBSUB_BACKEND` | Set to "NATS" to use NATS JetStream as the message broker | Yes | - | `NATS` |
| `PUBSUB_BROKER` | NATS server URL | Yes | - | `nats://localhost:4222` |
| `NATS_STREAM` | Name of the NATS stream | Yes | - | `mystream` |
| `NATS_SUBJECTS` | Comma-separated list of subjects to subscribe to | Yes | - | `orders.*,shipments.*` |
| `NATS_MAX_WAIT` | Maximum wait time for batch requests | No | - | `5s` |
| `NATS_MAX_PULL_WAIT` | Maximum wait time for individual pull requests | No | 0 | `500ms` |
| `NATS_CONSUMER` | Name of the NATS consumer | No | - | `my-consumer` |
| `NATS_CREDS_FILE` | Path to the credentials file for authentication | No | - | `/path/to/creds.json` |

#### Usage

When subscribing or publishing using NATS JetStream, make sure to use the appropriate subject name that matches your stream configuration.
For more information on setting up and using NATS JetStream, refer to the official NATS documentation.

### Azure Eventhub
GoFr supports eventhub starting gofr version v1.22.0.

While subscribing gofr reads from all the partitions of the consumer group provided in the configuration reducing hassle to manage them.

#### Configs

Eventhub is supported as an external pubsub provider such that if you are not using it, it doesn't get added in your binary.

Import the external driver for eventhub using the following command.

```bash
go get gofr.dev/pkg/gofr/datasources/pubsub/eventhub
```

Use the AddPubSub method of GoFr's app to connect

**Example**
```go
    app := gofr.New()
    
    app.AddPubSub(eventhub.New(eventhub.Config{
       ConnectionString:          "Endpoint=sb://gofr-dev.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=<key>",
       ContainerConnectionString: "DefaultEndpointsProtocol=https;AccountName=gofrdev;AccountKey=<key>;EndpointSuffix=core.windows.net",
       StorageServiceURL:         "https://gofrdev.windows.net/",
       StorageContainerName:      "test",
       EventhubName:              "test1",
    }))
```

While subscribing/publishing from eventhub make sure to keep the topic-name same as event-hub name. 

#### Setup

1. To setup azure eventhub refer the following [documentation](https://learn.microsoft.com/en-us/azure/event-hubs/event-hubs-create).

2. As GoFr manages reading from all the partitions it needs to store the information about what has been read and what is left for that GoFr uses Azure Container which can be setup from the following [documentation](https://learn.microsoft.com/en-us/azure/storage/blobs/blob-containers-portal).

##### Mandatory Configs Configuration Map
{% table %}
- ConnectionString
- [connection-string-primary-key](https://learn.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string)

---

- ContainerConnectionString
- [ConnectionString](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-keys-manage?toc=%2Fazure%2Fstorage%2Fblobs%2Ftoc.json&bc=%2Fazure%2Fstorage%2Fblobs%2Fbreadcrumb%2Ftoc.json&tabs=azure-portal#view-account-access-keys)


---

- StorageServiceURL
- [Blob Service URL](https://learn.microsoft.com/en-us/azure/storage/common/storage-account-get-info?tabs=portal#get-service-endpoints-for-the-storage-account)

---

- StorageContainerName
- [Container Name](https://learn.microsoft.com/en-us/azure/storage/blobs/blob-containers-portal#create-a-container)

---

- EventhubName
- [Eventhub](https://learn.microsoft.com/en-us/azure/event-hubs/event-hubs-create#create-an-event-hub)

{% /table %}

#### Example


## Subscribing
Adding a subscriber is similar to adding an HTTP handler, which makes it easier to develop scalable applications,
as it decoupled from the Sender/Publisher.
Users can define a subscriber handler and do the message processing and
use `app.Subscribe` to inject the handler into the application.
This is inversion of control pattern, which lets the control stay with the framework and eases the development 
and debugging process.

The subscriber handler has the following signature.
```go
func (ctx *gofr.Context) error
```

`Subscribe` method of GoFr App will continuously read a message from the configured `PUBSUB_BACKEND` which
can be either `KAFKA` or `GOOGLE` as of now. These can be configured in the configs folder under `.env`

> The returned error determines which messages are to be committed and which ones are to be consumed again.

```go
// First argument is the `topic name` followed by a handler which would process the 
// published messages continuously and asynchronously.
app.Subscribe("order-status", func(ctx *gofr.Context)error{
    // Handle the pub-sub message here
})
```

The context `ctx` provides user with the following methods:

* `Bind()` - Binds the message value to a given data type. Message can be converted to `struct`, `map[string]any`, `int`, `bool`, `float64` and `string` types.
* `Param(p string)/PathParam(p string)` - Returns the topic when the same is passed as param.


### Example
```go
package main

import (
	"gofr.dev/pkg/gofr"
)

func main() {
	app := gofr.New()

	app.Subscribe("order-status", func(c *gofr.Context) error {
		var orderStatus struct {
			OrderId string `json:"orderId"`
			Status  string `json:"status"`
		}

		err := c.Bind(&orderStatus)
		if err != nil {
			c.Logger.Error(err)
			
			// returning nil here as we would like to ignore the
			// incompatible message and continue reading forward
			return nil
		}

		c.Logger.Info("Received order ", orderStatus)

		return nil
	})

	app.Run()
}
```

## Publishing
The publishing of message is advised to done at the point where the message is being generated.
To facilitate this, user can access the publishing interface from `gofr Context(ctx)` to publish messages.

```go
ctx.GetPublisher().Publish(ctx, "topic", msg)
```

Users can provide the topic to which the message is to be published. 
GoFr also supports multiple topic publishing.
This is beneficial as applications may need to send multiple kinds of messages in multiple topics.

### Example
```go
package main

import (
	"encoding/json"

	"gofr.dev/pkg/gofr"
)

func main() {
	app := gofr.New()

	app.POST("/publish-order", order)

	app.Run()
}

func order(ctx *gofr.Context) (interface{}, error) {
	type orderStatus struct {
		OrderId string `json:"orderId"`
		Status  string `json:"status"`
	}

	var data orderStatus

	err := ctx.Bind(&data)
	if err != nil {
		return nil, err
	}

	msg, _ := json.Marshal(data)

	err = ctx.GetPublisher().Publish(ctx, "order-logs", msg)
	if err != nil {
		return nil, err
	}

	return "Published", nil
}
```
> #### Check out the following examples on how to publish/subscribe to given topics:
> ##### [Subscribing Topics](https://github.com/gofr-dev/gofr/blob/main/examples/using-subscriber/main.go)
> ##### [Publishing Topics](https://github.com/gofr-dev/gofr/blob/main/examples/using-publisher/main.go)# Getting started

GoFr is Opinionated Web Framework written in Go (Golang). It helps in building robust and scalable applications. This framework is designed to offer a user-friendly and familiar abstraction for all the developers. We prioritize simplicity over complexity.

In this section we will walk through what GoFr is, what problems it solves, and how it can help in building your project.

{% quick-links %}

{% quick-link title="Quick Start" icon="installation" href="/docs/quick-start/introduction" description="Step-by-step guides to setting up your system and installing the library." /%}

{% quick-link title="Examples" icon="plugins" href="https://github.com/gofr-dev/gofr/tree/main/examples" description="Our guides break down how to perform common tasks in GoFr." /%}

{% /quick-links %}

## Key Features

- Logging
- Support for various response types such as JSON, FILE.
- Health check and Readiness monitoring for checking continuous service availability.
- Metrics exposure for monitoring and analysis using Prometheus.
- Tracing capability to track user request progress with traceable spans.
- Level-based logging support for effective debugging and monitoring.

## Principles

- Promote simple and clean code.
- Favor compile-time checked code over dynamic code.
- Create a solid foundation for the integration of application modules.
- Encourage a more functional way of programming.
- Avoid code duplication.
- Log and store data for analysis purposes.
